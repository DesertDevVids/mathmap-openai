manual: WH,W,H statt wh,w,h
koordinatensystem erklaeren


> (i) Die Möglichkeit, bei 'user_slider(name,minimum,maximum)' als 'maximum'
> und 'minimum' Ausdrücke anzugeben, die von den Variablen 'X(nil:1)' und
> 'Y(nil:1)' abhängen.
> 
> (ii) Einen voreingestellten Wert für 'userslider' festzulegen (mit der
> gleichen Methode wie unter (i)).
> 
> (iii) Die Möglichkeit über den Dialog 'User Values' Werte direkt
> einzugeben (sowas wie das Eigabefeld <input> in HTML).


macos x:
  altivec
  multithreading (smp)
  movies (realtime!)




gimptool in Makefile statt gimp-config verwenden
radio buttons
NaN und Infty ausprobieren
init optimization
save expression in image




normalisierung von matrizen (matrix/determinante)
inverse matrix
pixel konvertieren schneller machen
abs cool machen (abs([-3,4]) sollt 5 sein, ned [3,4])







# make vertically seamless
# Thanks to Martin Weber
origValXY(x,y-sign(y)*Y)*abs(y)/Y+origVal(xy)*(1-(abs(y)/Y))

# make horizontally seamless
# Thanks to Martin Weber
origValXY(x-sign(x)*X,y)*abs(x)/X+origVal(xy)*(1-(abs(x)/X))







g = user_slider("granularity",0,50);
nxy = xy/R*g;
n = noise3([nxy[0],nxy[1],t*g]);
grayColor(n)*0.5+0.5








g = user_slider("granularity",0,50);
nxy = xy/R*g;
point = [nxy[0],nxy[1],t*g];
offset = (point + 0.5) / user_slider("offset granularity",0,50);
n1y = user_slider("n1y",0,10);
n1z = user_slider("n1z",0,10);
offset = [noise1(offset[0]),noise1(offset[1]),noise1(offset[2])] * user_slider("distortion",0,10);
#grayColor(offset[0]*0.5+0.5)
n = noise3(point+offset);
grayColor(n)*0.5+0.5












defun map ((nil:1)->nil:1 f, _:_ x)
    construct(x.tag:x.length, lambda (nil:1 i) f(x[i]) end)
end

defun map ((nil:1, nil:1)->nil:1 f, T:L x, T:L y)
    construct(x.tag:x.length, lambda (nil:1 i) f(x[i],y[i]) end)
end

defun __add (ri:2 a, ri:2 b)
    ri:[a[0]+b[0],a[1]+b[1]]
end

defun __add (T:L a, _:1 b)
    map(lambda (nil:1 x) x+b end, a)
end

defun __add (T:L a, T:L b)
    map(lambda (nil:1 x, nil:1 y)
            x+y
        end, a, b)
end

defun __mul (ri:2 a, ri:2 b)
    ri:[a[0]*b[0] - a[1]*b[1], a[0]*b[1] + b[0]*a[1]]
end

defun __div (ri:2 a, ri:2 b)
    if b == ri:[0,0] then
        ri:[0,0]
    else
        q = b[0] * b[0] + b[1] * b[1];
        ri:[(a[0]*b[0] + a[1]*b[1]) / q, (-a[0]*b[1] + b[0]*a[1]) / q]
    end
end








dx=-5;
dy=-5;
sum=rgba:[0,0,0,0];
num=0;
while dy < 6 do
    while dx < 6 do
        sum = sum + origVal(xy+xy:[dx,dy]);
        num = num + 1;
        dx = dx + 1
    end;
    dy = dy + 1
end;
sum / num













alpha = user_slider("alpha",0,360);
dir = xy:[cos(alpha),sin(alpha)];
ndir = xy:[-dir[1],dir[0]];
p = xy / m2x2:[dir[0],-ndir[0],
               dir[1],-ndir[1]];
pt = dir * p[0];
vec = xy - pt;
dist = -p[1] / R;
pos = 0.5 + p[0] / R / 2;
lower = user_curve("lower",pos) * 2 - 0.5;
upper = user_curve("upper",pos) * 2 - 0.5;
f = ((dist + 1) / 2 - lower) / (upper - lower);
origVal(pt + ndir * (f*2-1) * )R









# fractal noise
z = user_slider("z",0,10);
depth = floor(user_slider("depth",1,10));
pers = user_slider("persistence",0,1);
g = user_slider("granularity",0,50);
nxy = xy / R * g;
xyz = [nxy[0],nxy[1],z];
i = 1;
sum = 0;
max = 0;
while i < depth + 1 do
    sum = sum + noise(xyz*i) * (pers^i);
    max = max + (pers ^ i);
    i = i + 1
end;
grayColor(sum / (max * 2) + 0.5)









# fractal noise displace
z = user_slider("z",0,10);
depth = floor(user_slider("depth",1,10));
pers = user_slider("persistence",0,1);
g = user_slider("granularity",0,50);
strength = user_slider("strength",0,50);
nxy = xy / R * g;
xyz = [nxy[0],nxy[1],z];
i = 1;
sum = xy:[0,0];
max = 0;
while i < depth + 1 do
    persi = pers ^ i;
    sum = sum + xy:[noise(xyz*i),noise(xyz*i+[3.1415,2.71234,5.4322])] * persi;
    max = max + persi;
    i = i + 1
end;
val = sum / max;
origVal(xy + val * strength)













# smooth mugl
sl=30;
nx=floor(x/sl-0.5); ny=floor(y/sl-0.5);
alpha=[0,0,0,0];
radii=[0,0,0,0];
phii=[0,0,0,0];
xc=[0,0,0,0];
yc=[0,0,0,0];
heuslfaktor=sl/user_slider("size",1.2,5);
i=0; while i < 4 do
    ix=nx+i%2;
    iy=ny+floor(i/2);
    xc[i]=(ix+0.5)*sl;
    yc[i]=(iy+0.5)*sl;
    alpha[i]=(noise([ix*0.3,iy*0.3,0])+1)*180+t*360;
    kurde=toRA(xy:[x-xc[i],y-yc[i]])+ra:[0,pmod(alpha[i],360)];
    phii[i]=kurde[1];
    radii[i]=heuslfaktor*(1+noise([xc[i]+cos(kurde[1]),yc[i]+sin(kurde[1]),0]*2)*0.7);
    i = i + 1
end;
i=0;found=0;
while !found && i<4 do
    heuslkurde=toRA(xy:[x-xc[i],y-yc[i]])+ra:[0,alpha[i]];
    if heuslkurde[0]<radii[i] then
        found = 1
    else
        i=i+1
    end
end;
if i >= 4 then
    rgba:[0,0,1,1]
else
    if heuslkurde[0] < radii[i]-1.5 then
        origVal(toXY(heuslkurde)+xy:[xc[i],yc[i]])
    else
        rgba:[0,0,0,1]
    end
end







dur = user_slider("duration",0,5);
amp = exp(-t / dur);
front = t * R * 2;
dropxy = xy:[0,0];
dropr = toRA(xy - dropxy)[0];
disp = sin(dropr * 360 / user_slider("length",0,100) + t * 360 * user_slider("speed",0,100)) * cos(clamp(if front == 0 then 90 else dropr/front end * 90,0,90))^2 * user_slider("amp",0,100) * amp;
dispxy = toXY(ra:[disp,0]);
origVal(xy+dispxy)







dur = user_slider("duration",0,5);
amp = exp(-t / dur);
front = t * R * 2;
n = user_slider("num drops",1,20);
lastt = user_slider("t of last drop",0,1);
i = 0;
dispxy = xy:[0,0];
while i < n do
    dropt = scale(noise([n * pi, 0 * pi, 0]),-1,1,0,lastt);
    dropxy = xy:[noise([n * pi, pi, 0]),noise([n * pi, 2 * pi, 0])] * XY;
    dropr = (toRA(xy - dropxy))[0];
    disp = sin(dropr * 360 / user_slider("length",0,100) + t * 360 * user_slider("speed",0,100)) * cos(clamp(if front == 0 then 90 else dropr/front end * 90,0,90))^2 * user_slider("amp",0,100) * amp;
    dispxy = dispxy + toXY(ra:[disp,0]);
    i = i + 1
end;
origVal(xy+dispxy)






# radial displace
# tomr@aceldama.com
origVal(ra:[r+t*user_slider("MaxR",0,32)*((2*gray(origVal(xy,user_image("Radial"))))-1),a+t*user_slider("MaxA",0,360)*((2*gray(origVal(xy,user_image("Angle"))))-1)])






# frame diff
(origVal(xy,frame)-origVal(xy,frame-1))/2+rgba:[1/2,1/2,1/2,1]




# fade
origVal(xy,image:0,frame)*(1-t)+origVal(xy,image:1,frame)*t









# movie spiral
q=sin((r-a*0.1)*10+t*5*360)*0.5+0.5;
origVal(xy,image:0,frame)*(1-q)+origVal(xy,image:1,frame)*q









# pink ball
p=toHSVA(origVal(xy));
hg=0.9647;
dh=min(abs(p[0]-hg),abs(p[0]-(hg-1)));
ds=p[1]-0.6941;
if dh*dh+ds*ds < 0.05 then rgba:[1,1,1,1] else rgba:[0,0,0,1] end




# yellow ball
p=toHSVA(origVal(xy));
dh=p[0]-0.2;
ds=p[1]-0.65;
if dh*dh+ds*ds < 0.01 then rgba:[1,1,1,1] else rgba:[0,0,0,1] end




# green ball
p=toHSVA(origVal(xy));
dh=p[0]-0.3725;
ds=p[1]-0.7;
if dh*dh < 0.003 then rgba:[1,1,1,1] else rgba:[0,0,0,1] end






# slide (left->right) transition
if (x+X)/W < t then origVal(xy,image:0,frame) else origVal(xy,image:1,frame) end

st=15;p=clamp((x+X-t*W)/st+0.5,0,1);origVal(xy,image:0,frame)*(1-p)+origVal(xy,image:1,frame)*p





# wobbly transition
ns=user_slider("noise scale",0,100);
np=user_slider("noise speed",0,10);
bertl=user_slider("bertl",1,5);
mt=t*4;
pic1=user_image("input 1");
pic2=user_image("input 2");
nxy=xy/R*ns;
xyn1=noise([nxy[0],nxy[1],mt*np*1.5])*sin(t*180);
xyn2=noise([nxy[1],nxy[0],(mt+3)*np]);
l=clamp(xyn1*sin((mt+xyn2)*360)*bertl+t,0,1);
lerp(l,origVal(xy,pic1),origVal(xy,pic2))









g = user_slider("granularity",0,50);
nxy = xy/R*g;
z1 = user_slider("z1",0,10);
z2 = user_slider("z2",0,10);
w2 = user_slider("w2",0,1);
f2 = user_slider("f2",1,10);
thr = user_slider("threshold",-1,1);
n=noise([nxy[0]/2,nxy[1],z1])+noise([nxy[0]/2*f2,nxy[1]*f2,z2])*w2;
grayColor(if n >= thr then 1 else 0 end)
