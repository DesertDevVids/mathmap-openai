crash bei leerer expression->preview
normalisierung von matrizen (matrix/determinante)
inverse matrix
pixel konvertieren schneller machen
abs cool machen (abs([-3,4]) sollt 5 sein, ned [3,4])







# make vertically seamless
# Thanks to Martin Weber
origValXY(x,y-sign(y)*Y)*abs(y)/Y+origVal(xy)*(1-(abs(y)/Y))

# make horizontally seamless
# Thanks to Martin Weber
origValXY(x-sign(x)*X,y)*abs(x)/X+origVal(xy)*(1-(abs(x)/X))







g = user_slider("granularity",0,50);
nxy = xy/R*g;
n = noise3([nxy[0],nxy[1],t*g]);
grayColor(n)*0.5+0.5








g = user_slider("granularity",0,50);
nxy = xy/R*g;
point = [nxy[0],nxy[1],t*g];
offset = (point + 0.5) / user_slider("offset granularity",0,50);
n1y = user_slider("n1y",0,10);
n1z = user_slider("n1z",0,10);
offset = [noise1(offset[0]),noise1(offset[1]),noise1(offset[2])] * user_slider("distortion",0,10);
#grayColor(offset[0]*0.5+0.5)
n = noise3(point+offset);
grayColor(n)*0.5+0.5












defun map ((nil:1)->nil:1 f, _:_ x)
    construct(x.tag:x.length, lambda (nil:1 i) f(x[i]) end)
end

defun map ((nil:1, nil:1)->nil:1 f, T:L x, T:L y)
    construct(x.tag:x.length, lambda (nil:1 i) f(x[i],y[i]) end)
end

defun __add (ri:2 a, ri:2 b)
    ri:[a[0]+b[0],a[1]+b[1]]
end

defun __add (T:L a, _:1 b)
    map(lambda (nil:1 x) x+b end, a)
end

defun __add (T:L a, T:L b)
    map(lambda (nil:1 x, nil:1 y)
            x+y
        end, a, b)
end

defun __mul (ri:2 a, ri:2 b)
    ri:[a[0]*b[0] - a[1]*b[1], a[0]*b[1] + b[0]*a[1]]
end

defun __div (ri:2 a, ri:2 b)
    if b == ri:[0,0] then
        ri:[0,0]
    else
        q = b[0] * b[0] + b[1] * b[1];
        ri:[(a[0]*b[0] + a[1]*b[1]) / q, (-a[0]*b[1] + b[0]*a[1]) / q]
    end
end








dx=-5;
dy=-5;
sum=rgba:[0,0,0,0];
num=0;
while dy < 6 do
    while dx < 6 do
        sum = sum + origVal(xy+xy:[dx,dy]);
        num = num + 1;
        dx = dx + 1
    end;
    dy = dy + 1
end;
sum / num













alpha = user_slider("alpha",0,360);
dir = xy:[cos(alpha),sin(alpha)];
ndir = xy:[-dir[1],dir[0]];
p = xy / m2x2:[dir[0],-ndir[0],
               dir[1],-ndir[1]];
pt = dir * p[0];
vec = xy - pt;
dist = -p[1] / R;
pos = 0.5 + p[0] / R / 2;
lower = user_curve("lower",pos) * 2 - 0.5;
upper = user_curve("upper",pos) * 2 - 0.5;
f = ((dist + 1) / 2 - lower) / (upper - lower);
origVal(pt + ndir * (f*2-1) * )R









# fractal noise
z = user_slider("z",0,10);
depth = floor(user_slider("depth",1,10));
pers = user_slider("persistence",0,1);
g = user_slider("granularity",0,50);
nxy = xy / R * g;
xyz = [nxy[0],nxy[1],z];
i = 1;
sum = 0;
max = 0;
while i < depth + 1 do
    sum = sum + noise(xyz*i) * (pers^i);
    max = max + (pers ^ i);
    i = i + 1
end;
grayColor(sum / (max * 2) + 0.5)









# fractal noise displace
z = user_slider("z",0,10);
depth = floor(user_slider("depth",1,10));
pers = user_slider("persistence",0,1);
g = user_slider("granularity",0,50);
strength = user_slider("strength",0,50);
nxy = xy / R * g;
xyz = [nxy[0],nxy[1],z];
i = 1;
sum = xy:[0,0];
max = 0;
while i < depth + 1 do
    persi = pers ^ i;
    sum = sum + xy:[noise(xyz*i),noise(xyz*i+[3.1415,2.71234,5.4322])] * persi;
    max = max + persi;
    i = i + 1
end;
val = sum / max;
origVal(xy + val * strength)
