<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
  <head>
    <title>The MathMap Language Reference Manual</title>
  </head>

  <body>
    <center><h1>The MathMap Language Reference Manual</h1></center>

    <h2>The Type System</h2>

    <blockquote>
      <p>Every value in MathMap is a tagged tuple. This means it
	consists of one or more numbers (currently stupidly limited to
	9) and a symbolic tag. RGBA colors, for example are
	represented by tuples of length 4 with the tag <tt>rgba</tt>
	(for red, green, blue, alpha). The value
	<tt>rgba:[1,0,0,1]</tt> for example, represents the fully
	opaque color red.

      <p>Single numbers are represented by tuples of length 1 with
	the tag <tt>nil</tt> (which is the default tag). For sake of
	simplicity, single numbers need not be written in tuple
	syntax, i.e. <tt>3.1415</tt> is equivalent to
	<tt>nil:[3.1415]</tt>.

      <p>There are several other tuple tags which are used by
	MathMap:

      <table>
	<tr><td><b>Tag</b>    <td><b>Purpose</b></tr>
	<tr><td><tt>nil</tt>  <td>Default tag</tr>
	<tr><td><tt>rgba</tt> <td>RGBA Color</tr>
	<tr><td><tt>hsva</tt> <td>HSVA Color</tr>
	<tr><td><tt>ri</tt>   <td>Complex number</tr>
	<tr><td><tt>xy</tt>   <td>Cartesian coordinate</tr>
	<tr><td><tt>ra</tt>   <td>Polar coordinate</tr>
	<tr><td><tt>m2x2</tt> <td>2x2 matrix</tr>
	<tr><td><tt>m3x3</tt> <td>3x3 matrix</tr>
	<tr><td><tt>image</tt><td>Image ID</tr>
      </table>

      <p>In order for the tag system to make sense, operators and
	functions are overloaded based on the types of their
	arguments. In order for this to work at compile time, types
	must be statically determined. This means that any expression
	must have only one possible type, e.g. the expression <tt>if x
	then abc:[1,2,3] else xyz:[4,5] end</tt> is not valid.
	Furthermore, all assignments to the same variable must have
	the same type.  Hence, <tt>v=[1,2];v=[1,2,3]</tt> is not
	valid.

      <p>Tuple types are expressed in this manual in the form
	<tt>T:L</tt> where <tt>T</tt> is the tag and <tt>L</tt> is the
	length, e.g. <tt>rgba:[1,0,0,1]</tt> has the type
	<tt>rbga:4</tt>.

      <p>Elements of tuples can be extracted by the indexing
	operator <tt>[]</tt>. The expression <tt>p[0]</tt>, for
	example, extracts the first element of <tt>p</tt> and is of
	type <tt>nil:1</tt>.

    </blockquote>

    <h2>Variables</h2>

    <blockquote>
      In order for the expression to refer to a pixel in the
      original image, a few variables are set:

      <dl>
	<dt><tt>xy</tt> (<tt>xy:2</tt>)
	<dd>The cartesian coordinates of the pixel.

	<dt><tt>x</tt> (<tt>nil:1</tt>)
	<dd>The first component of the cartesian coordinates of the pixel.

	<dt><tt>y</tt> (<tt>nil:1</tt>)
	<dd>The second component of the cartesian coordinates of the pixel.

	<dt><tt>ra</tt> (<tt>ra:2</tt>)
	<dd>The polar coordinates of the pixel.

	<dt><tt>r</tt> (<tt>nil:1</tt>)
	<dd>The first component of the polar coordinates of the pixel
	  (<tt>0 &lt;= r &lt; 2*pi</tt>).

	<dt><tt>a</tt> (<tt>nil:1</tt>)
	<dd>The second component of the polar coordinates of the pixel
	  (the distance from the center).
      </dl>

      To make it easier to write expressions which depend on the
      image size, a few additional variables are set:

      <dl>
	<dt><tt>WH</tt> (<tt>xy:2</tt>)
	<dd>The size of the image.

	<dt><tt>W</tt> (<tt>nil:1</tt>)
	<dd>The width of the image.

	<dt><tt>H</tt> (<tt>nil:1</tt>)
	<dd>The height of the image.

	<dt><tt>R</tt> (<tt>nil:1</tt>)
	<dd>The biggest possible value for <tt>r</tt> for the image.

	<dt><tt>XY</tt> (<tt>xy:2</tt>)
	<dd>The biggest possible value (in both components) for
	  <tt>xy</tt>.

	<dt><tt>X</tt> (<tt>nil:1</tt>)
	<dd>The biggest possible value for <tt>x</tt> for the image.

	<dt><tt>Y</tt> (<tt>nil:1</tt>)
	<dd>The biggest possible value for <tt>y</tt> for the image.
      </dl>

      For the purpose of animations two additional variable are set:

      <dl>
	<dt><tt>t</tt> (<tt>nil:1</tt>)
	<dd>The time which is <tt>0 &lt;= t &lt; 1</tt>.  If animation
	is disabled, the value of <tt>t</tt> can be chosen in the
	Settings tab. If you want to make animations loop, set the
	'Periodic' check-box in the Settings tab and make sure that the
	images at <tt>t == 0</tt> and <tt>t == 1</tt> are the same.

	<dt><tt>frame</tt> (<tt>nil:1</tt>)
	<dd>The number of the current frame, beginning with <tt>0</tt>
	for the first frame.
      </dl>

    </blockquote>

    <h2>Constants</h2>

    <blockquote>

      MathMap defines a few constants to make your life easier:

      <dl>
        <dt><tt>pi</tt> (<tt>nil:1</tt>)
        <dd>3.1415926535...</dd>

        <dt><tt>e</tt> (<tt>nil:1</tt>)
        <dd>Euler's constant 2.7182818284...</dd>

        <dt><tt>I</tt> (<tt>ri:2</tt>)
        <dd>The imaginary unit <tt>ri:[0,1]</tt>
      </dl>

    </blockquote>

    <h2>Operators</h2>

    <blockquote>
      <p>MathMap operators are overloaded based on the types of
	their arguments. Arithmetic operators work as expected on real
	and on complex numbers. On tuples with the same length and tag
	they perform their operation element-wise. If their second
	argument is a tuple of length 1, they perform element-wise on
	the left operand always using the same right operand.

      <p>For example, <tt>[1,2,3]+[7,2,4]</tt> gives
        <tt>nil:[8,4,7]</tt>, while <tt>[1,2,3]+1</tt> gives
	<tt>nil:[2,3,4]</tt>.

      <p>Relational and logical operators currently only work on
	tuples with length 1.

      <blockquote>
	<dl>
	  <dt><tt>+</tt>
	  <dd>Addition

	  <dt><tt>-</tt>
	  <dd>Subtraction

	  <dt><tt>*</tt>
	  <dd>Multiplication.  Matrix-matrix, matrix-vector and
	    vector-matrix multiplication for 2x2 or 3x3 matrices
	    is done when the matrix has the type <tt>m2x2:4</tt> or
	    <tt>m3x3:9</tt>, respectively.

	  <dt><tt>/</tt>
	  <dd>Division.  Vector-matrix division is done for 2x2 or 3x3
	    matrices when the matrix has the type <tt>m2x2:4</tt> or
            <tt>m3x3:9</tt>, respectively.

	  <dt><tt>%</tt>
	  <dd>Modulo. This also works with real numbers.

	  <dt><tt>^</tt>
	  <dd>Exponentation. Does not perform on two tuples of length
	    greater 1.

	  <dt><tt>-</tt> (unary)
	  <dd>Arithmetic negation

	  <dt><tt>==</tt>
	  <dd>Gives <tt>1</tt> if the operands are equal,
	    otherwise <tt>0</tt>.

	  <dt><tt>!=</tt>
	  <dd>Gives <tt>1</tt> if the operands are not equal, otherwise
	    <tt>0</tt>.

	  <dt><tt>&lt;=</tt>
	  <dd>Gives <tt>1</tt> if the first operand is less or equal
	    than the second, <tt>0</tt> otherwise.

	  <dt><tt>&gt;=</tt>
	  <dd>Gives <tt>1</tt> if the first operand is greater or equal
	    than the second, <tt>0</tt> otherwise.

	  <dt><tt>&lt;</tt>
	  <dd>Gives <tt>1</tt> if the first operand is less
	    than the second, <tt>0</tt> otherwise.

	  <dt><tt>&gt;</tt>
	  <dd>Gives <tt>1</tt> if the first operand is greater
	    than the second, <tt>0</tt> otherwise.

	  <dt><tt>||</tt>
	  <dd>Returns <tt>1</tt> if at least one of the operands is not
	    <tt>0</tt>, otherwise <tt>0</tt>.

	  <dt><tt>&amp;&amp;</tt>
	  <dd>Returns <tt>1</tt> if both of the operands is not <tt>0</tt>,
	    otherwise <tt>0</tt>.

	  <dt><tt>!</tt> (unary)
	  <dd>Returns <tt>1</tt> if the operand is <tt>0</tt>, <tt>0</tt>
	    otherwise.

	  <dt><tt>;</tt>
	  <dd>Evaluates both operands (first the left one, then the right
	    one) and gives the value of the second.
	</dl>
      </blockquote>
    </blockquote>

    <h2>Conditionals and Loops</h2>

    <blockquote>
      <p>Conditions and invariants are always expected to be tuples of
        length 1.

      <blockquote>
	<dl>
	  <dt><tt>if <b>condition</b> then <b>consequence</b> end</tt>
	  <dd>Returns the value of <tt><b>consequence</b></tt> if the value of
	    <tt><b>condition</b></tt> is not <tt>0</tt>, <tt>0</tt> otherwise.
	</dl>

	<dl>
	  <dt><tt>if <b>condition</b> then <b>consequence</b> else <b>alternative</b> end</tt>
	  <dd>Returns the value of <tt><b>consequence</b></tt> if the value of
	    <tt><b>condition</b></tt> is not <tt>0</tt>, otherwise the value of
	    <tt><b>alternative</b></tt>.
	</dl>

	<dl>
	  <dt><tt>while <b>invariant</b> do <b>body</b> end</tt>
	  <dd>While <tt><b>invariant</b></tt> is not <tt>0</tt>, executes
	    <tt><b>body</b></tt>, then returns <tt>0</tt>.
	</dl>

	<dl>
	  <dt><tt>do <b>body</b> while <b>invariant</b> end</tt>
	  <dd>Executes <tt><b>body</b></tt> until <tt><b>invariant</b></tt> is not equal
	    <tt>0</tt>, then returns <tt>0</tt>.
	</dl>
      </blockquote>
    </blockquote>

    <h2>Built-in Functions</h2>

    <blockquote>

      <h3>Complex Numbers</h3>

      <blockquote>
        <p>Complex numbers have type <tt>ri:2</tt>.

	<dl>
	  <dt><tt>arg(x)</tt>
          <dd>Returns the argument of the complex value
            <tt>x == ri:[re,im]</tt>, which is <tt>atan(im/re)</tt>.

	  <dt><tt>conj(x)</tt>
	  <dd>Returns the conjugate complex of </tt>x == ri:[re,im]</tt>,
	    which is <tt>ri:[re,-im]</tt>.
	</dl>
      </blockquote>

      <h3>Vectors and Matrices</h3>

      <blockquote>
        <p>Only matrices of dimensions 2x2 and 3x3 are supported.
	  They must have the types <tt>m2x2:4</tt> and
	  <tt>m3x3:9</tt>, respectively.

        <dl>
	  <dt><tt>dotp(x,y)</tt>
	  <dd>Returns the scalar (inner) product of <tt>x</tt> and
	    <tt>y</tt>

	  <dt><tt>crossp(x,y)</tt>
	  <dd>Returns the cross (outer) product of <tt>x</tt> and
	    <tt>y</tt>, which must both have the length 3.

	  <dt><tt>det(m)</tt>
	  <dd>Returns the determinant of matrix <tt>m</tt>.

	  <dt><tt>normalize(v)</tt>
	  <dd>Returns a vector with the same direction as <tt>v</tt>
	    but with length 1. For example, <tt>normalize([2,0,0])</tt>
	    yields <tt>[1,0,0]</tt>.

	  <dt><tt>abs(x)</tt>
	  <dd>Returns the absolute value of <tt>x</tt>.  This works
	    with complex numbers and vectors.

	  <dt><tt>sum(t)</tt>
	  <dd>Returns the sum of all elements of the tuple <tt>t</tt>.
	</dl>
      </blockquote>

      <h3>Trigonometry</h3>

      <blockquote>
        <p>Trigonometric functions work with radians on real and
        complex numbers.

	<dl>
	  <dt><tt>deg2rad(x)</tt>
	  <dd>Returns the value <tt>x</tt> converted from degrees to
	    radians.

	  <dt><tt>rad2deg(x)</tt>
	  <dd>Returns the value <tt>x</tt> converted from radians to
	    degrees.

	  <dt><tt>toRA(xy)</tt>
	  <dd>Converts the cartesian coordinates <tt>xy</tt> (of type
	    <tt>xy:2</tt>) to polar coordinates (of type <tt>ra:2</tt>).

	  <dt><tt>toXY(ra)</tt>
	  <dd>Converts the polar coordinates <tt>ra</tt> (of type
	    <tt>ra:2</tt>) to cartesian coordinates (of type <tt>xy:2</tt>).

	  <dt><tt>sin(x)</tt>
	  <dd>Returns the sine of <tt>x</tt>.

	  <dt><tt>cos(x)</tt>
	  <dd>Returns the cosine of <tt>x</tt>.

	  <dt><tt>tan(x)</tt>
	  <dd>Returns the tangens of <tt>x</tt>.

	  <dt><tt>asin(x)</tt>
	  <dd>Returns the arc-sine of <tt>x</tt>.

	  <dt><tt>acos(x)</tt>
	  <dd>Returns the arc-cosine of <tt>x</tt>.

	  <dt><tt>atan(x)</tt>
	  <dd>Returns the arc-tangent of <tt>x</tt>.

	  <dt><tt>atan(y,x)</tt>
	  <dd>Returns the arc tangent of <tt>x</tt> and <tt>y</tt>
	    which is the same as <tt>atan(y/x)</tt>, except that
	    the signs of <tt>x</tt> and <tt>y</tt> are used to
	    determine the quadrant of the result.
        </dl>
      </blockquote>

      <h3>Hyperbolic Functions</h3>

      <blockquote>
        <p>Hyperbolic functions work on real and complex numbers.

	<dl>
	  <dt><tt>sinh(x)</tt>
	  <dd>Returns the hyperbolic sine of <tt>x</tt>.

	  <dt><tt>cosh(x)</tt>
	  <dd>Returns the hyperbolic cosine of <tt>x</tt>.

	  <dt><tt>tanh(x)</tt>
	  <dd>Returns the hyperbolic tangent of <tt>x</tt>.

	  <dt><tt>asinh(x)</tt>
	  <dd>Returns the hyperbolic arc-sine of <tt>x</tt>.

	  <dt><tt>acosh(x)</tt>
	  <dd>Returns the hyperbolic arc-cosine of <tt>x</tt>.

	  <dt><tt>atanh(x)</tt>
	  <dd>Returns the hyperbolic arc-tangent of <tt>x</tt>.
	</dl>
      </blockquote>

      <h3>Various Mathematical Functions</h3>

      <blockquote>
        <p>Functions work on and return tuples of length 1 unless noted
          otherwise.

        <dl>
	  <dt><tt>sqrt(x)</tt>
	  <dd>Returns the square root of <tt>x</tt>.  Only works on real
	  numbers.

	  <dt><tt>exp(x)</tt>
	  <dd>Returns <tt>e^x</tt>.  Works on real and complex numbers.

	  <dt><tt>log(x)</tt>
	  <dd>Returns the natural logarithm of <tt>x</tt>.  Works on real
	    and complex numbers.

	  <dt><tt>gamma(x)</tt>
          <dd>Returns the value of the gamma function for <tt>x</tt>.
	    Works on real and complex numbers.

	  <dt><tt>pmod(x,y)</tt>
	  <dd>Returns the modulo of <tt>x</tt> and <tt>y</tt> as a
	    positive value, even if <tt>x</tt> is negative.

	  <dt><tt>sign(x)</tt>
	  <dd>Returns <tt>-1</tt> if <tt>x &lt; 0</tt>, 0 if <tt>x = 0</tt>
	    and <tt>1</tt> if <tt>x &gt; 0</tt>. Works on two tuples of the
	    same length.

	  <dt><tt>floor(x)</tt>
	  <dd>Returns the largest integer which is less or equal to
	    <tt>x</tt>.

	  <dt><tt>min(x,y)</tt>
	  <dd>Returns x if <tt>x &lt; y</tt>, <tt>y</tt> otherwise. Works on
	    two tuples of the same arbitrary length.

	  <dt><tt>max(x,y)</tt>
	  <dd>Returns <tt>x</tt> if <tt>x &gt; y</tt>, <tt>y</tt> otherwise. Works on
	    two tuples of the same arbitrary length.

	  <dt><tt>clamp(x,l,u)</tt>
	  <dd>Clamps each element of <tt>x</tt> to be between the corresponding
	    elements of <tt>l</tt> and <tt>u</tt> and returns the result. All
	    three tuples must have the same tag and the same arbitrary length.

	  <dt><tt>lerp(t,a,b)</tt>
          <dd>Returns <tt>a*(1-t)+b*t</tt>. <tt>t</tt> must have length 1. <tt>a</tt>
	    and <tt>b</tt> must have the same tag and the same arbitrary length.

	  <dt><tt>scale(x,fl,fu,tl,tu)</tt>
	  <dd>Returns <tt>((x-fl)/(fu-fl))*(tu-tl)</tt>.

	  <dt><tt>inintv(a,x,y)</tt>
	  <dd>Returns <tt>1</tt> if <tt>x &lt;= a &lt;= y</tt>, <tt>0</tt> otherwise.
	</dl>
      </blockquote>

      <h3>Pseudo-Random Numbers</h3>

      <blockquote>
        <dl>
	  <dt><tt>rand(x,y)</tt>
	  <dd>Returns a random number <tt>a</tt> with <tt>x &lt;= a &lt;= y</tt>. Successive
	    random numbers are evenly distributed within the interval.

	  <dt><tt>noise(coord)</tt>
	  <dd>Returns the value of a solid noise function at coordinate <tt>coord</tt>.
	    <tt>coord</tt> must have length 3. The returned value is in the interval
	    -1 to 1.
        </dl>
      </blockquote>

      <h3>Colors</h3>

      <blockquote>
        <p>Colors must have types <tt>rgba:4</tt> or <tt>hsva:4</tt>,
	  depending on whether they are in the RGB or the HSV color
	  space.

	<dl>
	  <dt><tt>red(p)</tt>
	  <dd>Returns the red component of
	    <tt>p</tt>, which is <tt>0 &lt;= red(p) &lt;= 1</tt>.

	  <dt><tt>green(p)</tt>
	  <dd>Returns the green component of <tt>p</tt>, which is
	    <tt>0 &lt;= green(p) &lt;= 1</tt>.

	  <dt><tt>blue(p)</tt>
	  <dd>Returns the blue component of <tt>p</tt>, which is
	    <tt>0 &lt;= blue(p) &lt;= 1</tt>.

	  <dt><tt>alpha(p)</tt>
	  <dd>Returns the alpha component of <tt>p</tt>, which is
	    <tt>0 &lt;= alpha(p) &lt;= 1</tt>.

	  <dt><tt>gray(p)</tt>
	  <dd>Returns the luminance of <tt>p</tt>, which is
	    <tt>0 &lt;= gray(p) &lt;= 1</tt>.

	  <dt><tt>toRGBA(c)</tt>
	  <dd>Transforms the color <tt>c</tt> to RGBA. Returns an
	    <tt>rgba:4</tt> tuple.

	  <dt><tt>toHSVA(c)</tt>
	  <dd>Transforms the color <tt>c</tt> to HSVA. Returns an
	    <tt>hsva:4</tt> tuple.

	  <dt><tt>rgbColor(r,g,b)</tt>
	  <dd>Returns the <tt>rgba</tt> value of a pixel with red component
	    <tt>r</tt>, green component <tt>g</tt>, blue component
	    <tt>b</tt> and alpha component <tt>1</tt>. This function
	    is provided for compatibility.

	  <dt><tt>rgbaColor(r,g,b,a)</tt>
	  <dd>Returns the <tt>rgba</tt> value of a pixel with red component
	    <tt>r</tt>, green component <tt>g</tt>, blue component
	    <tt>b</tt> and alpha component <tt>a</tt>. This function
	    is provided for compatibility.

	  <dt><tt>grayColor(g)</tt>
	  <dd>Returns the <tt>rgba</tt> value of a pixel with luminance
	    <tt>g</tt> and alpha component <tt>1</tt>.

	  <dt><tt>grayaColor(g,a)</tt>
	  <dd>Returns the <tt>rgba</tt> value of a pixel with luminance
	    <tt>g</tt> and alpha component <tt>a</tt>.
        </dl>
      </blockquote>

      <h3>Input Images</h3>

      <blockquote>
        <dl>
	  <dt><tt>origVal(coord)</tt>
	  <dd>Returns the <tt>rgba</tt> value of the pixel at coordinate
	    <tt>coord</tt>. <tt>coord</tt> may be of type <tt>xy:2</tt>
	    or <tt>ra:2</tt>.

	  <dt><tt>origVal(coord,image)</tt>
	  <dd>Returns the <tt>rgba</tt> value of the pixel at coordinate
	    <tt>coord</tt> in the image <tt>image</tt>. <tt>coord</tt> may
	    be of type <tt>xy:2</tt> or <tt>ra:2</tt>. <tt>image</tt> must
	    be of type <tt>image:1</tt> and must be a value returned by
	    <tt>user_image</tt>.

	  <dt><tt>origValXY(x,y)</tt>
	  <dd>Returns the pixel value of the pixel at the cartesian
	    position (<tt>x</tt>,<tt>y</tt>). This function is provided
	    for compatibility.

	  <dt><tt>origValRA(r,a)</tt>
	  <dd>Returns the pixel value of the pixel at the polar
	    position (<tt>r</tt>,<tt>a</tt>). This function is provided
	    for compatibility.
	</dl>
      </blockquote>
    </blockquote>

    <h2>User Values</h2>

    <blockquote>
      <p>User values are values within the expression which are
        specified through the graphical interface. Each user value
        must have a name. User values sometimes take arguments, like
        <tt>user_float</tt>, in this case to specify the range of
        allowed values.

      <dl>
        <dt><tt>user_float(name,minimum,maximum)</tt>
        <dt><tt>user_slider(name,minimum,maximum)</tt>
	<dd>Returns a tuple of type <tt>nil:1</tt> corresponding to
	  the chosen number in the range <tt>minimum</tt> to
	  <tt>maximum</tt>.

        <dt><tt>user_int(name,minimum,maximum)</tt>
	<dd>Returns a tuple of type <tt>nil:1</tt> corresponding to
	  the chosen integer in the range <tt>minimum</tt> to
	  <tt>maximum</tt>.

	<dt><tt>user_bool(name)</tt>
	<dd>Returns the tuple <tt>nil:[1]</tt> or <tt>nil:[0]</tt>
	  depending on whether the user has activated a push button.

	<dt><tt>user_color(name)</tt>
	<dd>Returns a tuple of type <tt>rgba:4</tt> corresponding to
	  the color the user has chosen in a color well.

	<dt><tt>user_curve(name,x)</tt>
	<dd>Returns a tuple of type <tt>nil:1</tt> corresponding to
	  the value of a curve at position <tt>x</tt>. The curve is
	  defined in the interval <tt>0</tt> to <tt>1</tt>. Its values
	  are in the same interval. If <tt>x</tt> is outside the
	  interval, it is clamped.

	<dt><tt>user_gradient(name,x)</tt>
	<dd>Returns the value of a user-defined gradient at the
	  value <tt>x</tt>.  The gradient is defined in the interval
	  <tt>0</tt> to <tt>1</tt>.  Values outside this interval
	  are clamped.  The returned tuple is a color of type
	  <tt>rgba:4</tt>.

	<dt><tt>user_image(name)</tt>
        <dd>Returns a tuple of type <tt>image:1</tt> containing the
	  ID of a user-selected image. The user may only select images
	  having the same size as the input image.
      </dl>
    </blockquote>
  </body>
</html>
