<HTML>
<HEAD>
<title>The MathMap Language Tutorial</title>
</HEAD>
<BODY>

<center><h1>The MathMap Language Tutorial</h1></center>

<p>MathMap is a language for transforming existing
images and producing entirely new images.  Think of it as the ultimate
image and animation filter.  This flexibility, however, comes at a
price: Using MathMap to create a new transformation isn't as simple as
using some pre-built image manipulation filter.  Instead, you have to
precisely describe what MathMap should do.  This usually requires a
bit of math knowledge (for most tasks, high-school math is more than
sufficient) and it is necessary to know the MathMap language.

<p>This document is a gentle introduction to the
MathMap language.  Very little mathematical knowledge is assumed, and
almost no programming skills are needed--although they certainly would
come in handy.

<p>Please take the time to read through this introduction.  Try out
the examples we give and play around with them.  Change them a little
and see what happens.  That way, you will quickly gain a feeling for
what you can achieve with MathMap and in which ways.  If you do this,
we are confident that you will soon create your own image filters and
maybe even get hooked on MathMap.

<p>This tutorial deals with the following topics:

<dt>
<li><a href="#basics">Basic Principles</a>
<li><a href="#cartesian">The Cartesian Coordinate System</a>
<li><a href="#inputImages">Input Images</a>
<li><a href="#polar">The Polar Coordinate System</a>
<li><a href="#conditionals">Conditionals</a>
<li><a href="#variables">Variables</a>
<li><a href="#userValues">User Values</a>
<li><a href="#animations">Animations</a>
</dt>

<h2><a name="basics"></a>Basic Principles</h2>

<blockquote>
<p>The basic operating principle of MathMap is very
simple.  To create an image of a given size, MathMap simply iterates
through all the elements (pixels) of the image to be created and
"asks" your expression how the pixel in question should look like,
i.e. what color it should have.

<p>Let's make an expression that produces a white image:

<blockquote>
<pre>
grayColor(1)
</pre>
</blockquote>

<p><tt>grayColor</tt> is a function producing a gray level color.
What it needs to know is the gray level you want to produce.  In this
case, the gray level we want is <tt>1</tt> which is for
white.  <tt>0</tt> is black, and <tt>0.5</tt> is halfway between.  If
you provide a value greater than <tt>1</tt>, <tt>1</tt>
will be used instead (there is no color whiter than white!).
Similarly, <tt>0</tt> will be used if a value less than <tt>0</tt> is
presented to the function.

<p>Such values given to functions are called <em>arguments</em>.  As
we have just seen, <tt>grayColor</tt> takes exactly one
argument.  Arguments are always given to a function after its name,
enclosed in parenthesis.  As we will shortly see, if a function takes
more than one argument, these arguments are separated by commata.

<p>Producing gray levels is fun, but we'd like to play around with
"real" colors, too.  So, let's produce a red image:

<blockquote>
<pre>
rgbColor(1,0,0)
</pre>
</blockquote>

<p>As you can see, <tt>rgbColor</tt> takes three arguments and
produces a color.  It's first argument is the amount of red in the
color.  The second argument is the color's green component, and the
third argument specifies the blue component.  Again, useful values
range from <tt>0</tt> to <tt>1</tt>.  Values too large
or too small are clipped to <tt>1</tt> or <tt>0</tt>, respectively.
Try to change the values and see how it affects the output color.
</blockquote>

<h2><a name="cartesian"></a>The Cartesian Coordinate System</h2>

<blockquote>
<p>So far, the pixels in our images always had the same color.  When
we produce images with multiple colors, we usually want to determine
the color based on the position of the pixel in question.

<p>MathMap allows access to the coordinates of the pixel being
calculated.  It supports two coordinate systems.  The first one, which
you are certainly familiar with, is the cartesian coordinate system.
Each pixel has two coordinates, called <tt>x</tt> and
<tt>y</tt>.  The following figure illustrates the cartesian coordinate
system:

<p><img src="cartesian.png">

<p>The point labeled "O" is the <em>origin</em> of the coordinate
system.  Both its coordinates (<tt>x</tt> and <tt>y</tt>) are zero.
The origin is always in the center of the image.  The point "p" in the
illustration has a value of <tt>50</tt> for the coordinate <tt>x</tt>
and <tt>20</tt> for <tt>y</tt>.  That's because it's
<tt>50</tt> pixels to the right of the origin and <tt>20</tt> pixels
above.  As you can see, <tt>x</tt> increases by one as you go one
pixel to the right, while <tt>y</tt> increases by one if you go one
pixel up.  Similarly, they decrease when going in the opposite
directions.  That means that pixels to the left of the origin have
negative <tt>x</tt> coordinates and pixels below it have negative
<tt>y</tt> coordinates.

<p>Let's use this knowledge to produce an image which is black on the
left, white on the right and has gray levels in between.  We want to
produce this image:

<p><img src="graygradient.png">

<p>For the creation of this image, it helps to know that the constant
<tt>W</tt> contains the width of the image to be created.

<p>We know that we can use <tt>grayColor</tt> to
produce a gray level.  However, we need a number between <tt>0</tt>
and <tt>1</tt> to get colors between black and white.
Let's look at what we have.  At the right edge of the image the value
of <tt>x</tt> is half the width of the image (since the
origin is always at the center), i.e. <tt>W/2</tt>.  Similarly, at the
left edge, it has the same absolute value, only it's negative,
i.e. <tt>-W/2</tt>.  In order to get <tt>0</tt> (for
black) for the left edge, we can simply add <tt>W/2</tt> to
<tt>x</tt>.  That gives us <tt>x+W/2</tt> which is <tt>0</tt> at the
left edge of the image.  At the right edge, however, its value is
<tt>W</tt>, instead of <tt>1</tt>.  We can solve this problem by
simply dividing our expression by <tt>W</tt>, giving
<tt>(x+W/2)/W</tt>.  Now we have what we want, and we can give this
expression as an argument to <tt>grayColor</tt>:

<blockquote>
<pre>
grayColor((x+W/2)/W)
</pre>
</blockquote>

<p>Try to do the same for the <tt>y</tt> coordinate, i.e. make a
gradient from bottom to top instead of from left to right.  You might
need to know that the constant <tt>H</tt> holds the
height of the image.  You could also try to combine both coordinates
to produce a gradient which goes from the bottom left corner to the
top right corner.
</blockquote>

<h2><a name="inputImages"></a>Input Images</h2>

<blockquote>
<p>While it's fun to produce completely new images, it is often nice
or necessary to modify existing ones.  We will use this image as our
input image:

<p><img src="clown.jpg">

<p>The function <tt>origValXY</tt> looks up a pixel in
the input image given its cartesian coordinates and returns its color.
Hence, the expression

<blockquote>
<pre>
origValXY(x,y)
</pre>
</blockquote>

<p>simply copies the input image, which is not very exciting.  A very
simple effect is to flip the image horizontally.  This can be achieved
by changing the sign of the <tt>x</tt> coordinate,
i.e. making negative coordinates positive and vice versa:

<blockquote>
<pre>
origValXY(-x,y)
</pre>
</blockquote>

<p>Try it out for yourself.  Also, try to predict what would happen if
you changed the sign of the <tt>y</tt> coordinate instead, then try it
out and see if you were right.

<p>Now, let's shake the waves with our image.  The function
<tt>sin</tt> will come in handy for our purposes.  This is what its
graph looks like (by the way, this graph was produced by a MathMap,
using an expression by Hans Lundmark):

<p><img src="sinegraph.png">

<p>As you can see, the value of <tt>sin</tt> oscillates
between <tt>-1</tt> and <tt>1</tt>.  The length of its oscillation
period (the distance it needs to make a whole "cycle") is
<tt>2*pi</tt>.  The value of <tt>pi</tt>, as is well known, is about
<tt>3.14159</tt>.

<p>We will now try to shift whole pixel columns up and down, depending
on their <tt>x</tt> coordinates.  The shift pattern will resemble the
graph of the <tt>sin</tt> function, only that we will
use a period of 60 pixels, and we will shift at most <tt>10</tt>
pixels up or down:

<blockquote>
<pre>
origValXY(x,y+10*sin(x*(2*pi)/60))
</pre>
</blockquote>

<p>The resulting image looks like this:

<p><img src="sineclown.jpg">
</blockquote>

<h2><a name="polar"></a>The Polar Coordinate System</h2>

<blockquote>
<p>In addition to the familiar cartesian coordinate system, MathMap
provides the polar coordinate system.  Each pixel has two polar
coordinates, namely <tt>r</tt> and <tt>a</tt>.  The
following illustration helps in understanding the polar coordinate
system:

<p><img src="polar.png">

<p>The value of <tt>r</tt> is simply the distance from the origin
(i.e. the center of the image) to that pixel.

<p>The value of <tt>a</tt> is the angle between the positive x-axis
and the line from the origin to the point in question.

<p>However, the angle is not measured in degrees
(<tt>0</tt>-<tt>360</tt>), but in radians, which range from <tt>0</tt>
to <tt>2*pi</tt>.  This may seem a bit awkward, but it is more
convenient mathematically.  However, MathMap provides two functions to
convert between radians and degrees, namely <tt>rad2deg</tt> and
<tt>deg2rad</tt>.

<p>Polar coordinates make it very easy to generate pond-like effects.
When we try the wavy expression from above and use polar instead of
cartesian coordinates, leaving the <tt>a</tt>
coordinate unchanged and shifting the <tt>r</tt>
coordinate, we get the following expression:

<blockquote>
<pre>
origValRA(r+10*sin(r*(2*pi)/60),a)
</pre>
</blockquote>

<p>which generates this image:

<p><img src="clownpond.jpg">
</blockquote>

<h2><a name="conditionals"></a>Conditionals</h2>

<blockquote>
<p>Let's create an image which looks like a target:

<p><img src="target.png">

<p>Obviously, whether a pixel is red or white depends solely on its
distance from the center, which we know is available as <tt>r</tt>.  I
have chosen the width of each ring as <tt>20</tt>, i.e. the distance
between the radii of the inner circles of two neighboring red (or
white) rings is <tt>40</tt>.  Hence, the expression we
are looking for is periodic with a period of <tt>40</tt>.

<p>To solve this problem, we will use the modulo operator, which is
available as <tt>%</tt>.  Its value is the remainder of the division
of its left operand by its right operand.  As an example, <tt>7%3</tt>
is <tt>1</tt> because the remainder of the division of
<tt>7</tt> by <tt>3</tt> is <tt>1</tt>.
This operation is periodic.  Its period is the value of its right
operand (the divisor).  Furthermore, the result of the operation is
never greater than the right operand.  So, for example, <tt>r%40</tt>
is periodic with a period of <tt>40</tt> and is always
between <tt>0</tt> (inclusive) and <tt>40</tt> (exclusive).  Let's see
what this looks like:

<blockquote>
<pre>
grayColor((r%40)/40)
</pre>
</blockquote>

<p>In order to be nice to <tt>grayColor</tt>, the value
is scaled to be in the range from <tt>0</tt> to <tt>1</tt> (instead of
<tt>40</tt>).  The resulting image looks like this:

<p><img src="rmod.jpg">

<p>You can see that the value starts out as <tt>0</tt> at the center
of the image, climbs to <tt>1</tt> at <tt>40</tt> pixels from the
center and then immediately drops to <tt>0</tt> again, repeating this
cycle forever (well, in our case, to the boundaries of the image).

<p>You may want to try to leave out the rescaling "<tt>/40</tt>" to
see the difference.

<p>All we have to do now is to check whether we are in the first half
of a period (in which case <tt>r%40</tt> is less than <tt>20</tt>), or
in the second.  If we are in the first, the color for the pixel is
red, otherwise it is white.  MathMap provides a construct for such
decisions:

<blockquote>
<pre>
if r%40 < 20 then
  rgbColor(1,0,0)
else
  rgbColor(1,1,1)
end
</pre>
</blockquote>

<p>The indentation is used merely to make the expression easier to
read. You can indent your code any way you like (or not at all).

<p>The expression should be easy enough to understand.  If the
condition is fulfilled, the result is the color red, otherwise it is
the color white.
</blockquote>

<h2><a name="variables"></a>Variables</h2>

<blockquote>
<p>Sometimes you want to use one value in multiple places in your
expression.  It's not necessary to write that value twice.  Instead
you give it a name by which you can refer to it.  Let's say we want to
produce an image like this:

<p><img src="clownhole.jpg">

<p>As you can see, the pixels from the original image fade to black
with the distance from the center.  They reach the black color at the
top and bottom edges of the image.

<p>The variable <tt>r</tt> which holds the distance from the center of
the image is measured in pixels, so its value at the centers of the
top and bottom edges is half the height of the image,
i.e. <tt>H/2</tt>.  If we scale this down to <tt>1</tt>, it's much
easier to work with, so we'll use <tt>r/(H/2)</tt>.  This expression's
value is <tt>0</tt> at the center of the image and increases with the
distance from the center.  It reaches <tt>1</tt>
exactly where we want the color to be solid black.  However, at
greater distances from the center it grows larger than <tt>1</tt>,
which we don't want, so we limit it with the function <tt>min</tt>.
This function takes two arguments and returns the smaller of the two.
Hence, <tt>min(r/(H/2),1)</tt> never exceeds
<tt>1</tt>.  (There's also a function <tt>max</tt>,
which returns the larger of its two arguments.)

<p>Given the color of a pixel in the original image and its
transformed (as above) distance from the center, we can now figure out
what to do.  If the transformed distance is <tt>0</tt>
(in the center) we want the original color unchanged.  If it's
<tt>1</tt>, we want the color black.  We can reach that effect by
multiplying the three color components of the pixel by <tt>1</tt>
minus the transformed distance, i.e. <tt>1-min(r/(H/2),1)</tt>.

<p>We can use the functions <tt>red</tt>,
<tt>green</tt>, and <tt>blue</tt> to access the
components of a color.  Now we could write the red component of our
output image as <tt>red(origValXY(x,y))*(1-min(r/(H/2),1))</tt>.  We'd
have to use equivalent expressions for the green and blue components
and then use them as arguments to <tt>rgbColor</tt>.  By assigning the
values <tt>origValXY(x,y)</tt> and <tt>1-min(r/(H/2),1)</tt> to
variables, which we call <tt>p</tt> and <tt>d</tt> (you
can choose any name you like, as long as it's not the name of a
built-in constant or variable or a keyword; consult the <a
href="reference.html">MathMap reference</a> for the names of all
those), we can write the resulting expression as
<tt>rgbColor(red(p)*d,green(p)*d,blue(p)*d)</tt>.  The complete
expression is:

<blockquote>
<pre>
p=origValXY(x,y);
d=1-min(r/(H/2),1);
rgbColor(red(p)*d,green(p)*d,blue(p)*d)
</pre>
</blockquote>

<p>As you can see, assigning values to variables is very
straightforward.  You must separate variable assignments and other
expressions with semicola.

<p>By the way: Using more advanced features of MathMap you can write
an expression equivalent to the above as

<blockquote>
<pre>
lerp(r/Y,origVal(xy),grayColor(0))
</pre>
</blockquote>

<p>So, please go on reading, there's more to come.
</blockquote>

<h2><a name="userValues"></a>User Values</h2>

<blockquote>
<p>Sometimes you need to put some values into your expression which
are more or less arbitrary.  Often you want to try out several
different values, and it's tedious to change the expression every time
by hand.  That's where user values come in.  Let's reiterate our wave
example:

<blockquote>
<pre>
origValXY(x,y+10*sin(x*(2*pi)/60))
</pre>
</blockquote>

<p>There are two parameters here which we have chosen more or less
arbitrarily, namely the amplitude of the wave (in this case
<tt>10</tt>) and the wave length (in this cas <tt>60</tt>).  Wouldn't
it be nice if we could change these values with sliders instead of
having to edit the expression?

<p>That's exactly what <tt>user_slider</tt> provides.
It generates a user interface element (a slider) and hands the chosen
value to the expression:

<blockquote>
<pre>
amp=user_slider("Amplitude",0,100);
len=user_slider("Wavelength",1,200);
origValXY(x,y+amp*sin(x*(2*pi)/len))
</pre>
</blockquote>

<p><tt>user_slider</tt> takes three arguments: the name of the slider
(for identification purposes in the user interface), the minimum and
the maximum values.  Try it out!

<p>There are not only user value functions for numbers, but also for
colors, color gradients, curves and even images.  Image user values
make it possible to have more than one input image in an expression.
Check out the <a href="reference.html">Reference Manual</a> for
details.
</blockquote>

<h2><a name="tuples"></a>Tuples and Tags</h2>

<blockquote>
<p>Now it's time to look at a more technical subject, namely MathMap's
type system.  The type system of MathMap is designed to be as
invisible as possible, but in order to unleash MathMap's full
potential, you will need to know one or two things about it.  Don't
worry, it's not very complicated.

<p>Sometimes it's convenient to treat two or more numbers as a single
value.  One such example is colors.  A single color is actually four
distinct numbers.  We have already come across three of them, namely
the red, green, and blue components.  The fourth is the color's
transparency value, called <em>alpha</em>.  A color with an alpha of
<tt>1</tt> is completely opaque, like all the colors we have seen so
far.  An alpha component of <tt>0</tt> means full
transparency, <tt>0.5</tt> means half transparent, and
so on.

<p>So far, we have always treated colors as single values.  We have
constructed colors using functions such as <tt>rgbColor</tt> and
retrieved its components with functions like <tt>red</tt>.  We can,
however, do these things without using those functions.  This, for
example, is the half-transparent color green:

<blockquote>
<pre>
rgba:[0,1,0,0.5]
</pre>
</blockquote>

<p>One or more numbers within square brackets, separated by commata,
constitute a <em>tuple</em>.  So, tuples are just ordered collections
of numbers.  They are ordered because MathMap remembers in which order
you have written their components.  For example, the tuple
<tt>[1,2,3]</tt> is not the same as <tt>[3,2,1]</tt>.

<p>The name <tt>rgba</tt> is a <em>tag</em>.  The tag <tt>rgba</tt>
tells MathMap that that tuple is not just four numbers, but a color
with red, green, blue and alpha components.  This begs the question
whether there are other kinds of colors.  Actually, there are.
MathMap also supports colors in the so-called HSV color space.  Those
colors are given the tag <em>hsva</em>.  MathMap uses the tags to
determine how to interpret the numbers in the tuples.

<p>Many operators and functions work on tuples as well as on single
numbers.  The functions <tt>min</tt> and <tt>max</tt> for example,
calculate the minimum and maximum values for each tuple element.  To
set the red component of an image to <tt>0</tt>, for example, you can
use the following expression:

<blockquote>
<pre>
max(origValXY(x,y),rgba:[0,1,1,1])
</pre>
</blockquote>
</blockquote>

<h2><a name="animations"></a>Animations</h2>

<blockquote>
<p>MathMap provides the functionality to create animations.  To that
end, the language provides a variable called <tt>t</tt>.  For each
single picture in the animation (such pictures are called
<em>frames</em>) <tt>t</tt> has a different value, depending on the
position of the frame within the whole animation.  The first picture
in the image always has <tt>t</tt> set to <tt>0</tt>,
while for the last picture it is set to <tt>1</tt>.  Actually, the
latter statement isn't always true, as we will discover shortly, but
for the time being, simply assume that it is.

<p>The following expression produces an animation which fades from
black to white:

<blockquote>
<pre>
grayColor(t)
</pre>
</blockquote>

<p>You will often want to produce animations which loop seemlessly,
i.e. which looks like one endless animation when looped.  For such
animations, make it so that the image with a <tt>t</tt>
value of <tt>1</tt> looks exactly like the one with a value of
<tt>0</tt>, like in the following expression:

<blockquote>
<pre>
grayColor(sin((t*2*pi+1)/2))
</pre>
</blockquote>

<p>The problem here is that if MathMap would render the first image in
the animation with <tt>t</tt> as <tt>0</tt> and the
last image with <tt>t</tt> as <tt>1</tt>, you would
have the same frame twice when looping.  Therefore, MathMap lets you
choose (in the user interface) whether you would like to create a
periodic (looping) animation or not.  If you do, <tt>t</tt> never
reaches <tt>1</tt> at the end of the animation but stops shortly
before, depending on how many frames you want your animation to have.
For example, for a periodic animation with <tt>9</tt>
frames, <tt>t</tt> takes on the values <tt>0</tt>, <tt>0.1</tt>,
<tt>0.2</tt>, ... <tt>0.9</tt>.

<p>Hint: One way to make periodic animations is to use periodic
functions like <tt>sin</tt>, <tt>cos</tt> or the modulo
operator <tt>%</tt>.
</blockquote>

<h2><a name="functions"></a>Some Useful Functions</h2>

<blockquote>
<p>Here is an overview of some MathMap functions which are very useful
in many situations.  This is not a complete function reference.  If
you are looking for one, you'll find it in the <a
href="reference.html">Reference Manual</a>.

<h3>scale</h3>

<blockquote>
<p>Quite often you find that you have a value which varies within a
given range, but you want the range to be different.  Take, for
example the gray gradient:

<p><img src="graygradient.png">

<p>The variable <tt>x</tt> varies from <tt>-W/2</tt> to <tt>W/2</tt>
but you want it to be between <tt>0</tt> and <tt>1</tt>.  In such
cases you can use the <tt>scale</tt> function.  The
expression <tt>scale(x,-W/2,W/2,0,1)</tt> is <tt>0</tt>
when <tt>x</tt> is <tt>-W/2</tt> and <tt>1</tt> when
<tt>x</tt> is <tt>W/2</tt>.  Hence, you can create the
above image with the expression

<blockquote>
<pre>
grayColor(scale(x,-W/2,W/2,0,1))
</pre>
</blockquote>
</blockquote>

<h3>lerp</h3>

<blockquote>
<p>Suppose we want to produce a gradient from red to green:

<p><img src="redgreengradient.png">

<p>We know from above that we can use <tt>scale(x,-W/2,W/2,0,1)</tt>
for a value which is <tt>0</tt> at the left image edge
and <tt>1</tt> at the right edge.  <tt>lerp</tt> does
the rest: it takes two tuples and produces a value which is "in
between" these two values by the same amount as its first argument is
in between <tt>0</tt> and <tt>1</tt>.  Hence, the gradient above can
be produced by this expression:

<blockquote>
<pre>
lerp(scale(x,-W/2,W/2,0,1),rgbColor(1,0,0),rgbColor(0,1,0))
</pre>
</blockquote>
</blockquote>

<h3>inintv</h3>

<blockquote>
<p>The function <tt>inintv</tt> makes it easy to check whether a value
lies within a given range.  <tt>inintv</tt> has a value
of <tt>1</tt> if the condition is fulfilled, and of <tt>0</tt>
otherwise.  You can use this as a condition if in <tt>if</tt>
expression, or as a value in its own right.  For example, this
expression draws a white ring with an inner radius of <tt>50</tt> and
an outer radius of <tt>60</tt>:

<blockquote>
<pre>
grayColor(inintv(r,50,60))
</pre>
</blockquote>
</blockquote>

<h3>clamp</h3>

<blockquote>
<p>Sometimes you have values which you want to lie within a given
range.  In case they don't, you simply want them to take on the
largest value within the range, if they are too large, or the smallest
if they are too small.

<p>MathMap often does such operations authomatically, for example if
you produce colors with components larger than <tt>1</tt> or smaller
than <tt>0</tt>.

<p>If you have to it yourself, <tt>clamp</tt> can help you.  For
example, <tt>clamp(v,[0,0,0],[1,1,1])</tt> restricts every element of
<tt>v</tt> to be in the range from <tt>0</tt> to <tt>1</tt>.
</blockquote>

<h3>rand</h3>

<blockquote>
<p>The function <tt>rand</tt> generates a random number.  It takes two
arguments: The minimum and the maximum value of the number to be
generated.  This expression, for examples, randomly scatters the
pixels of the input image (but not more than 10 pixels away from their
original location in both directions):

<blockquote>
<pre>
origValXY(x+rand(-10,10),y+rand(-10,10))
</pre>
</blockquote>
</blockquote>

<h3>noise</h3>

<blockquote>
<p>In image manipulation, one often needs a functions which is random
but doesn't change as abruptly as <tt>rand</tt> does.  <tt>noise</tt>
is a so-called <em>solid noise</em> function.  It takes a tuple of
three numbers and returns a value between <tt>-1</tt> and <tt>1</tt>.
If the input arguments change only by a little, so does the resulting
value.  The overall "look" of the function is random, though.  It's
hard to describe, so it's best you see for yourself:

<blockquote>
<pre>
grayColor(scale(noise([x/20,y/20,t*2]),-1,1,0,1))
</pre>
</blockquote>

<p>As you can see, the third input value depends on <tt>t</tt>, so try
out changing <tt>t</tt>.  For <tt>t</tt> being <tt>0</tt>, the
resulting image looks like this:

<p><img src="noise.jpg">
</blockquote>
</blockquote>

<h2><a name="furtherInformation"></a>Further Information</h2>

<blockquote>
<p>This tutorial has, despite its length, not covered all features and
details of MathMap.  For example, we didn't even mention loops (a
programming language feature having nothing to do with animations).

<p>To get more detailed information about the MathMap language, see
the <a href="reference.html">MathMap Reference Manual</a>.

<p>A very good way to learn how to do things with MathMap is to look
at the examples supplied with it.  Pick the examples you find
interesting, look at their expressions, and try to figure out how they
work.

<p>You might also want to look at the <a
href="http://www.complang.tuwien.ac.at/schani/">MathMap Homepage</a>
for announcements, new documentation or interesting links.

<p>If you like MathMap, or if you have suggestions or questions
regarding the MathMap language or user interface, feel free to <a
href="mailto:schani@complang.tuwien.ac.at">contact the author</a>.  I
am looking forward to your feedback.
</blockquote>

</BODY>
</HTML>
