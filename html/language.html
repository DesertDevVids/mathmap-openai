<HTML>
<HEAD>
<STYLE type="text/css">
<!--
   H1.mmSection {border-width: 1; border: solid; text-align: center; 
                 color: red; font-variant: small-caps }
   H2.mmSubSection {border-width: 1; border: solid; color: red }
   P.mmText { color: black }
   P.mmFigure { color: black }
   PRE.mmMMExpression { color: blue }
   TT.mmMath { color: blue }
   EM.mmEMPanic { color: green }
   DT.mmDTtoc { color: blue }
-->
</STYLE>
<META http-equiv="Content-Style-Type" content="text/css">
</HEAD>
<BODY>

<h1 class="mmSection">The MathMap Language</h1>

<p class="mmText">MathMap is a language for transforming existing
images and producing entirely new images.  Think of it as the ultimate
image and animation filter.  This flexibility, however, comes at a
price: Using MathMap to create a new transformation isn't as simple as
using some pre-built image manipulation filter.  Instead, you have to
precisely describe what MathMap should do.  This usually requires a
bit of math knowledge (for most tasks, high-school math is more than
sufficient) and it is necessary to know the MathMap language.

<p class="mmText">This document is a gentle introduction to the
MathMap language.  Very little mathematical knowledge is assumed, and
almost no programming skills are needed--although they certainly would
come in handy.

<p class="mmText">Please take the time to <em>read through this
introduction</em>.  Try out the examples we give and play around with
them.  Change them a little and see what happens.  That way, you will
quickly gain a feeling for what you can achieve with MathMap and in
which ways.  If you do this, we are confident that you will soon
create your own image filters and maybe even get hooked on MathMap.

<p class="mmText">This tutorial deals with the following topics:

<dt class="mmDTtoc">
<li><a href="#basics">Basic Principles</a>
<li><a href="#cartesian">The Cartesian Coordinate System</a>
<li><a href="#inputImages">Input Images</a>
<li><a href="#polar">The Polar Coordinate System</a>
<li><a href="#conditionals">Conditionals</a>
<li><a href="#variables">Variables</a>
<li><a href="#userValues">User Values</a>
<li><a href="#animations">Animations</a>
</dt>

<h2 class="mmSubSection"><a name="basics"></a>Basic Principles</h2>

<p class="mmText">The basic operating principle of MathMap is very
simple.  To create an image of a given size, MathMap simply iterates
through all the elements (pixels) of the image to be created and
"asks" your expression how the pixel in question should look like,
i.e. what color it should have.

<p class="mmText">Let's make an expression that produces a white image:

<pre class="mmMMExpression">
grayColor(1)
</pre>

<p class="mmText"><tt class="mmMath">grayColor</tt> is a function
producing a gray level color.  What it needs to know is the gray level
you want to produce.  In this case, the gray level we want is <tt
class="mmMath">1</tt> which is for white.  <tt class="mmMath">0</tt>
is black, and <tt class="mmMath">0.5</tt> is halfway between.  If you
provide a value greater than <tt class="mmMath">1</tt>, <tt
class="mmMath">1</tt> will be used instead (there is no color whiter
than white!).  Similarly, <tt class="mmMath">0</tt> will be used if a
value less than <tt class="mmMath">0</tt> is presented to the
function.

<p class="mmText">Such values given to functions are called
<em>arguments</em>.  As we have just seen, <tt
class="mmMath">grayColor</tt> takes exactly one argument.  Arguments
are always given to a function after its name, enclosed in
parenthesis.  As we will shortly see, if a function takes more than
one argument, these arguments are separated by commata.

<p class="mmText">Producing gray levels is fun, but we'd like to play
around with "real" colors, too.  So, let's produce a red image:

<pre class="mmMMExpression">
rgbColor(1,0,0)
</pre>

<p class="mmText">As you can see, <tt class="mmMath">rgbColor</tt>
takes three arguments and produces a color.  It's first argument is
the amount of red in the color.  The second argument is the color's
green component, and the third argument specifies the blue component.
Again, useful values range from <tt class="mmMath">0</tt> to <tt
class="mmMath">1</tt>.  Values too large or too small are clipped to
<tt class="mmMath">1</tt> or <tt class="mmMath">0</tt>, respectively.
Try to change the values and see how it affects the output color.

<h2 class="mmSubSection"><a name="cartesian"></a>The Cartesian Coordinate System</h2>

<p class="mmText">So far, the pixels in our images always had the same
color.  When we produce images with multiple colors, we usually want
to determine the color based on the position of the pixel in question.

<p class="mmText">MathMap allows access to the coordinates of the
pixel being calculated.  It supports two coordinate systems.  The
first one, which you are certainly familiar with, is the cartesian
coordinate system.  Each pixel has two coordinates, called <tt
class="mmMath">x</tt> and <tt class="mmMath">y</tt>.  The following
figure illustrates the cartesian coordinate system:

<p class="mmFigure"><img src="cartesian.png">

<p class="mmText">The point labeled "O" is the <em>origin</em> of the
coordinate system.  Both its coordinates (<tt class="mmMath">x</tt>
and <tt class="mmMath">y</tt>) are zero.  The origin is always in the
center of the image.  The point "p" in the illustration has a value of
<tt class="mmMath">50</tt> for the coordinate <tt
class="mmMath">x</tt> and <tt class="mmMath">20</tt> for <tt
class="mmMath">y</tt>.  That's because it's <tt class="mmMath">50</tt>
pixels to the right of the origin and <tt class="mmMath">20</tt>
pixels above.  As you can see, <tt class="mmMath">x</tt> increases by
one as you go one pixel to the right, while <tt class="mmMath">y</tt>
increases by one if you go one pixel up.  Similarly, they decrease
when going in the opposite directions.  That means that pixels to the
left of the origin have negative <tt class="mmMath">x</tt> coordinates
and pixels below it have negative <tt class="mmMath">y</tt>
coordinates.

<p class="mmText">Let's use this knowledge to produce an image which
is black on the left, white on the right and has gray levels in
between.  We want to produce this image:

<p class="mmFigure"><img src="graygradient.png">

<p class="mmText">For the creation of this image, it helps to know
that the constant <tt class="mmMath">W</tt> contains the width of the
image to be created.

<p class="mmText">We know that we can use <tt
class="mmMath">grayColor</tt> to produce a gray level.  However, we
need a number between <tt class="mmMath">0</tt> and <tt
class="mmMath">1</tt> to get colors between black and white.  Let's
look at what we have.  At the right edge of the image the value of <tt
class="mmMath">x</tt> is half the width of the image (since the origin
is always at the center), i.e. <tt class="mmMath">W/2</tt>.
Similarly, at the left edge, it has the same absolute value, only it's
negative, i.e. <tt class="mmMath">-W/2</tt>.  In order to get <tt
class="mmMath">0</tt> (for black) for the left edge, we can simply add
<tt class="mmMath">W/2</tt> to <tt class="mmMath"
class="mmMath">x</tt>.  That gives us <tt class="mmMath">x+W/2</tt>
which is <tt class="mmMath">0</tt> at the left edge of the image.  At
the right edge, however, its value is <tt class="mmMath">W</tt>,
instead of <tt class="mmMath">1</tt>.  We can solve this problem by
simply dividing our expression by <tt class="mmMath">W</tt>, giving
<tt class="mmMath">(x+W/2)/W</tt>.  Now we have what we want, and we
can give this expression as an argument to <tt
class="mmMath">grayColor</tt>:

<pre class="mmMMExpression">
grayColor((x+W/2)/W)
</pre>

<p class="mmText">Try to do the same for the <tt class="mmMath">y</tt>
coordinate, i.e. make a gradient from bottom to top instead of from
left to right.  You might need to know that the constant <tt
class="mmMath">H</tt> holds the height of the image.  You could also
try to combine both coordinates to produce a gradient which goes from
the bottom left corner to the top right corner.

<h2 class="mmSubSection"><a name="inputImages"></a>Input Images</h2>

<p class="mmText">While it's fun to produce completely new images, it
is often nice or necessary to modify existing ones.  We will use this
image as our input image:

<p class="mmFigure"><img src="clown.jpg">

<p class="mmText">The function <tt class="mmMath"
class="mmMath">origValXY</tt> looks up a pixel in the input image
given its cartesian coordinates and returns its color.  Hence, the
expression

<pre class="mmMMExpression">
origValXY(x,y)
</pre>

<p class="mmText">simply copies the input image, which is not very
exciting.  A very simple effect is to flip the image horizontally.
This can be achieved by changing the sign of the <tt
class="mmMath">x</tt> coordinate, i.e. making negative coordinates
positive and vice versa:

<pre class="mmMMExpression">
origValXY(-x,y)
</pre>

<p class="mmText">Try it out for yourself.  Also, try to predict what
would happen if you changed the sign of the <tt class="mmMath">y</tt>
coordinate instead, then try it out and see if you were right.

<p class="mmText">Now, let's shake the waves with our image.  The
function <tt class="mmMath">sin</tt> will come in handy for our
purposes.  This is what its graph looks like (by the way, this graph
was produced by a MathMap, using an expression by Hans Lundmark):

<p class="mmFigure"><img src="sinegraph.png">

<p class="mmText">As you can see, the value of <tt
class="mmMath">sin</tt> oscillates between <tt class="mmMath">-1</tt>
and <tt class="mmMath">1</tt>.  The length of its oscillation period
(the distance it needs to make a whole "cycle") is <tt
class="mmMath">2*pi</tt>.  The value of <tt class="mmMath">pi</tt>, as
is well known, is about <tt class="mmMath">3.14159</tt>.

<p class="mmText">We will now try to shift whole pixel columns up and
down, depending on their <tt class="mmMath">x</tt> coordinates.  The
shift pattern will resemble the graph of the <tt
class="mmMath">sin</tt> function, only that we will use a period of 60
pixels, and we will shift at most <tt class="mmMath">10</tt> pixels up
or down:

<pre class="mmMMExpression">
origValXY(x,y+10*sin(x*(2*pi)/60))
</pre>

<p class="mmText">The resulting image looks like this:

<p class="mmFigure"><img src="sineclown.jpg">

<h2 class="mmSubSection"><a name="polar"></a>The Polar Coordinate System</h2>

<p class="mmText"><em class="mmEMPanic">DON'T PANIC!!!</em>

<p class="mmText">In addition to the familiar cartesian coordinate
system, MathMap provides the polar coordinate system.  Each pixel has
two polar coordinates, namely <tt class="mmMath">r</tt> and <tt
class="mmMath">a</tt>.  The following illustration helps in
understanding the polar coordinate system:

<p class="mmFigure"><img src="polar.png">

<p class="mmText">The value of <tt class="mmMath">r</tt> is simply the
distance from the origin (i.e. the center of the image) to that pixel.

<p class="mmText">The value of <tt class="mmMath">a</tt> is the angle
between the positive x-axis and the line from the origin to the point
in question.

<p class="mmText">However, the angle is not measured in degrees (<tt
class="mmMath">0</tt>-<tt class="mmMath">360</tt>), but in radians,
which range from <tt class="mmMath">0</tt> to <tt
class="mmMath">2*pi</tt>.  This may seem a bit awkward, but it is more
convenient mathematically.  However, MathMap provides two functions to
convert between radians and degrees, namely <tt
class="mmMath">rad2deg</tt> and <tt class="mmMath">deg2rad</tt>.

<p class="mmText">Polar coordinates make it very easy to generate
pond-like effects.  When we try the wavy expression from above and use
polar instead of cartesian coordinates, leaving the <tt
class="mmMath">a</tt> coordinate unchanged and shifting the <tt
class="mmMath">r</tt> coordinate, we get the following expression:

<pre class="mmMMExpression">
origValRA(r+10*sin(r*(2*pi)/60),a)
</pre>

<p class="mmText">which generates this image:

<p class="mmFigure"><img src="clownpond.jpg">

<h2 class="mmSubSection"><a name="conditionals"></a>Conditionals</h2>

<p class="mmText">Let's create an image which looks like a target:

<p class="mmFigure"><img src="target.png">

<p class="mmText">Obviously, whether a pixel is red or white depends
solely on its distance from the center, which we know is available as
<tt class="mmMath">r</tt>.  I have chosen the width of each ring as
<tt class="mmMath">20</tt>, i.e. the distance between the radii of the
inner circles of two neighboring red (or white) rings is <tt
class="mmMath">40</tt>.  Hence, the expression we are looking for is
periodic with a period of <tt class="mmMath">40</tt>.

<p class="mmText">To solve this problem, we will use the modulo
operator, which is available as <tt class="mmMath">%</tt>.  Its value
is the remainder of the division of its left operand by its right
operand.  As an example, <tt class="mmMath">7%3</tt> is <tt
class="mmMath">1</tt> because the remainder of the division of <tt
class="mmMath">7</tt> by <tt class="mmMath">3</tt> is <tt
class="mmMath">1</tt>.  This operation is periodic.  Its period is the
value of its right operand (the divisor).  Furthermore, the result of
the operation is never greater than the right operand.  So, for
example, <tt class="mmMath">r%40</tt> is periodic with a period of <tt
class="mmMath">40</tt> and is always between <tt class="mmMath">0</tt>
(inclusive) and <tt class="mmMath">40</tt> (exclusive).  Let's see
what this looks like:

<pre class="mmMMExpression">
grayColor((r%40)/40)
</pre>

<p class="mmText">In order to be nice to <tt
class="mmMath">grayColor</tt>, the value is scaled to be in the range
from <tt class="mmMath">0</tt> to <tt class="mmMath">1</tt> (instead
of <tt class="mmMath">40</tt>).  The resulting image looks like this:

<p class="mmFigure"><img src="rmod.png">

<p class="mmText">You can see that the value starts out as 
<tt class="mmMath" class="mmMath">0</tt> at the center of
the image, climbs to <tt class="mmMath">1</tt> at 
<tt class="mmMath">40</tt> pixels from the center
and then immediately drops to <tt class="mmMath">0</tt> again, 
repeating this cycle forever (well, in our case, to the boundaries 
of the image).

<p class="mmText">You may want to try to leave out the rescaling
"<tt class="mmMath">/40</tt>" to see the difference.

<p class="mmText">All we have to do now is to check whether we are 
in the first half of a period (in which case <tt class="mmMath">r%40</tt> 
is less than <tt class="mmMath">20</tt>), or in the second.  If we 
are in the first, the color for the pixel is red, otherwise it is white.  
MathMap provides a construct for such decisions:

<pre class="mmMMExpression">
if r%40 < 20 then
  rgbColor(1,0,0)
else
  rgbColor(1,1,1)
end
</pre>

<p class="mmText">The indentation is used merely to make the 
expression easier to read. You can indent your code any way 
you like (or not at all).

<p class="mmText">The expression should be easy enough to 
understand.  If the condition is fulfilled, the result is 
the color red, otherwise it is the color white.

<h2 class="mmSubSection"><a name="variables"></a>Variables</h2>

<p class="mmText">Sometimes you want to use one value in multiple
places in your expression.  It's not necessary to write that value
twice.  Instead you give it a name by which you can refer to it.
Let's say we want to produce an image like this:

<p class="mmFigure"><img src="clownhole.jpg">

<p class="mmText">As you can see, the pixels from the original image
fade to black with the distance from the center.  They reach the black
color at the top and bottom edges of the image.

<p class="mmText">The variable <tt class="mmMath">r</tt> which holds
the distance from the center of the image is measured in pixels, so
its value at the centers of the top and bottom edges is half the
height of the image, i.e. <tt class="mmMath">H/2</tt>.  If we scale
this down to <tt class="mmMath">1</tt>, it's much easier to work with,
so we'll use <tt class="mmMath">r/(H/2)</tt>.  This expression's value
is <tt class="mmMath">0</tt> at the center of the image and increases
with the distance from the center.  It reaches <tt
class="mmMath">1</tt> exactly where we want the color to be solid
black.  However, at greater distances from the center it grows larger
than <tt class="mmMath">1</tt>, which we don't want, so we limit it
with the function <tt class="mmMath">min</tt>.  This function takes
two arguments and returns the smaller of the two.  Hence, <tt
class="mmMath">min(r/(H/2),1)</tt> never exceeds <tt
class="mmMath">1</tt>.  (There's also a function <tt
class="mmMath">max</tt>, which returns the larger of its two
arguments.)

<p class="mmText">Given the color of a pixel in the original image and
its transformed (as above) distance from the center, we can now figure
out what to do.  If the transformed distance is <tt
class="mmMath">0</tt> (in the center) we want the original color
unchanged.  If it's <tt class="mmMath">1</tt>, we want the color
black.  We can reach that effect by multiplying the three color
components of the pixel by <tt class="mmMath">1</tt> minus the
transformed distance, i.e. <tt class="mmMath">1-min(r/(H/2),1)</tt>.

<p class="mmText">We can use the functions <tt
class="mmMath">red</tt>, <tt class="mmMath">green</tt>, and <tt
class="mmMath">blue</tt> to access the components of a color.  Now we
could write the red component of our output image as <tt
class="mmMath">red(origValXY(x,y))*(1-min(r/(H/2),1))</tt>.  We'd have
to use equivalent expressions for the green and blue components and
then use them as arguments to <tt class="mmMath">rgbColor</tt>.  By
assigning the values <tt class="mmMath">origValXY(x,y)</tt> and <tt
class="mmMath">1-min(r/(H/2),1)</tt> to variables, which we call <tt
class="mmMath">p</tt> and <tt class="mmMath">d</tt> (you can choose
any name you like, as long as it's not the name of a built-in constant
or variable or a keyword; consult the <a href="reference.html">MathMap
reference</a> for the names of all those), we can write the resulting
expression as <tt
class="mmMath">rgbColor(red(p)*d,green(p)*d,blue(p)*d)</tt>.  The
complete expression is:

<pre class="mmMMExpression">
p=origValXY(x,y);
d=1-min(r/(H/2),1);
rgbColor(red(p)*d,green(p)*d,blue(p)*d)
</pre>

<p class="mmText">As you can see, assigning values to variables is
very straightforward.  You must separate variable assignments and
other expressions with semicola.

<p class="mmText">By the way: Using more advanced features of MathMap
you can write an expression equivalent to the above as

<pre class="mmMMExpression">
lerp(r/Y,origVal(xy),grayColor(0))
</pre>

<p class="mmText">So, please go on reading, there's more to come.

<h2 class="mmSubSection"><a name="userValues"></a>User Values</h2>

<p class="mmText">Sometimes you need to put some values into your
expression which are more or less arbitrary.  Often you want to try
out several different values, and it's tedious to change the
expression every time by hand.  That's where user values come in.
Let's reiterate our wave example:

<pre class="mmMMExpression">
origValXY(x,y+10*sin(x*(2*pi)/60))
</pre>

<p class="mmText">There are two parameters here which we have chosen
more or less arbitrarily, namely the amplitude of the wave (in this
case <tt class="mmMath">10</tt>) and the wave length (in this cas <tt
class="mmMath">60</tt>).  Wouldn't it be nice if we could change these
values with sliders instead of having to edit the expression?

<p class="mmText">That's exactly what <tt
class="mmMath">user_slider</tt> provides.  It generates a user
interface element (a slider) and hands the chosen value to the
expression:

<pre class="mmMMExpression">
amp=user_slider("Amplitude",0,100);
len=user_slider("Wavelength",1,200);
origValXY(x,y+amp*sin(x*(2*pi)/len))
</pre>

<p class="mmText"><tt class="mmMath">user_slider</tt> takes three
arguments: the name of the slider (for identification purposes in the
user interface), the minimum and the maximum values.  Try it out!

<p class="mmText">There are not only user value functions for numbers,
but also for colors, color gradients, curves and even images.  Image
user values make it possible to have more than one input image in an
expression.  Check out the <a href="reference.html">Reference
Manual</a> for details.

<h2 class="mmSubSection"><a name="tuples"></a>Tuples and Tags</h2>

<p class="mmText">Now it's time to look at a more technical subject,
namely MathMap's type system.  The type system of MathMap is designed
to be as invisible as possible, but in order to unleash MathMap's full
potential, you will need to know one or two things about it.  Don't
worry, it's not very complicated.

<p class="mmText">Sometimes it's convenient to treat two or more
numbers as a single value.  One such example is colors.  A single
color is actually four distinct numbers.  We have already come across
three of them, namely the red, green, and blue components.  The fourth
is the color's transparency value, called <em>alpha</em>.  A color
with an alpha of <tt class="mmMath">1</tt> is completely opaque, like
all the colors we have seen so far.  An alpha component of <tt
class="mmMath">0</tt> means full transparency, <tt
class="mmMath">0.5</tt> means half transparent, and so on.

<p class="mmText">So far, we have always treated colors as single
values.  We have constructed colors using functions such as <tt
class="mmMath">rgbColor</tt> and retrieved its components with
functions like <tt class="mmMath">red</tt>.  We can, however, do these
things without using those functions.  This, for example, is the
half-transparent color green:

<pre class="mmMMExpression">
rgba:[0,1,0,0.5]
</pre>

<p class="mmText">One or more numbers within square brackets,
separated by commata, constitute a <em>tuple</em>.  So, tuples are
just ordered collections of numbers.  They are ordered because MathMap
remembers in which order you have written their components.  For
example, the tuple <tt class="mmMath">[1,2,3]</tt> is not the same as
<tt class="mmMath">[3,2,1]</tt>.

<p class="mmText">The name <tt class="mmMath">rgba</tt> is a
<em>tag</em>.  The tag <tt class="mmMath">rgba</tt> tells MathMap that
that tuple is not just four numbers, but a color with red, green, blue
and alpha components.  This begs the question whether there are other
kinds of colors.  Actually, there are.  MathMap also supports colors
in the so-called HSV color space.  Those colors are given the tag
<em>hsva</tt>.  MathMap uses the tags to determine how to interpret
the numbers in the tuples.

<p class="mmText">Many operators and functions work on tuples as well
as on single numbers.  The functions <tt class="mmMath">min</tt> and
<tt class="mmMath">max</tt> for example, calculate the minimum and
maximum values for each tuple element.  To set the red component of an
image to <tt class="mmMath">0</tt>, for example, you can use the
following expression:

<pre class="mmMMExpression">
max(origValXY(x,y),rgba:[0,1,1,1])
</pre>

<h2 class="mmSubSection"><a name="animations"></a>Animations</h2>

<p class="mmText">MathMap provides the functionality to create
animations.  To that end, the language provides a variable called <tt
class="mmMath">t</tt>.  For each single picture in the animation (such
pictures are called <em>frames</em>) <tt class="mmMath">t</tt> has a
different value, depending on the position of the frame within the
whole animation.  The first picture in the image always has <tt
class="mmMath">t</tt> set to <tt class="mmMath">0</tt>, while for the
last picture it is set to <tt class="mmMath">1</tt>.  Actually, the
latter statement isn't always true, as we will discover shortly, but
for the time being, simply assume that it is.

<p class="mmText">The following expression produces an animation which
fades from black to white:

<pre class="mmMMExpression">
grayColor(t)
</pre>

<p class="mmText">You will often want to produce animations which loop
seemlessly, i.e. which looks like one endless animation when looped.
For such animations, make it so that the image with a <tt
class="mmMath">t</tt> value of <tt class="mmMath">1</tt> looks exactly
like the one with a value of <tt class="mmMath">0</tt>, like in the
following expression:

<pre class="mmMMExpression">
grayColor(sin((t*2*pi+1)/2))
</pre>

<p class="mmText">The problem here is that if MathMap would render the
first image in the animation with <tt class="mmMath">t</tt> as <tt
class="mmMath">0</tt> and the last image with <tt
class="mmMath">t</tt> as <tt class="mmMath">1</tt>, you would have the
same frame twice when looping.  Therefore, MathMap lets you choose (in
the user interface) whether you would like to create a periodic
(looping) animation or not.  If you do, <tt class="mmMath">t</tt>
never reaches <tt class="mmMath">1</tt> at the end of the animation
but stops shortly before, depending on how many frames you want your
animation to have.  For example, for a periodic animation with <tt
class="mmMath">9</tt> frames, <tt class="mmMath">t</tt> takes on the
values <tt class="mmMath">0</tt>, <tt class="mmMath">0.1</tt>, <tt
class="mmMath">0.2</tt>, ... <tt class="mmMath">0.9</tt>.

<p class="mmText">Hint: One way to make periodic animations is to use
periodic functions like <tt class="mmMath">sin</tt>, <tt
class="mmMath">cos</tt> or the modulo operator <tt
class="mmMath">%</tt>.

<h2 class="mmSubSection"><a name="functions"></a>Some Useful Functions</h2>

<p class="mmText">Here is an overview of some MathMap functions which
are very useful in many situations.  This is not a complete function
reference.  If you are looking for one, you'll find it in the <a
href="reference.html">Reference Manual</a>.

<h3 class="mmSubSubSection">scale</h3>

<p class="mmText">Quite often you find that you have a value which
varies within a given range, but you want the range to be different.
Take, for example the gray gradient:

<p class="mmFigure"><img src="graygradient.png">

<p class="mmText">The variable <tt class="mmMath">x</tt> varies from
<tt class="mmMath">-W/2</tt> to <tt class="mmMath">W/2</tt> but you
want it to be between <tt class="mmMath">0</tt> and <tt
class="mmMath">1</tt>.  In such cases you can use the <tt
class="mmMath">scale</tt> function.  The expression <tt
class="mmMath">scale(x,-W/2,W/2,0,1)</tt> is <tt class="mmMath">0</tt>
when <tt class="mmMath">x</tt> is <tt class="mmMath">-W/2</tt> and <tt
class="mmMath">1</tt> when <tt class="mmMath">x</tt> is <tt
class="mmMath">W/2</tt>.  Hence, you can create the above image with
the expression

<pre class="mmMMExpression">
grayColor(scale(x,-W/2,W/2,0,1))
</pre>

<h3 class="mmSubSubSection">lerp</h3>

<p class="mmText">Suppose we want to produce a gradient from red to
green:

<p class="mmFigure"><img src="redgreengradient.png">

<p class="mmText">We know from above that we can use <tt
class="mmMath">scale(x,-W/2,W/2,0,1)</tt> for a value which is <tt
class="mmMath">0</tt> at the left image edge and <tt
class="mmMath">1</tt> at the right edge.  <tt class="mmMath">lerp</tt>
does the rest: it takes two tuples and produces a value which is "in
between" these two values by the same amount as its first argument is
in between <tt class="mmMath">0</tt> and <tt class="mmMath">1</tt>.
Hence, the gradient above can be produced by this expression:

<pre class="mmMMExpression">
lerp(scale(x,-W/2,W/2,0,1),rgbColor(1,0,0),rgbColor(0,1,0))
</pre>

<h3 class="mmSubSubSection">inintv</h3>

<p class="mmText">The function <tt class="mmMath">inintv</tt> makes it
easy to check whether a value lies within a given range.  <tt
class="mmMath">inintv</tt> has a value of <tt class="mmMath">1</tt> if
the condition is fulfilled, and of <tt class="mmMath">0</tt>
otherwise.  You can use this as a condition if in <tt
class="mmMath">if</tt> expression, or as a value in its own right.
For example, this expression draws a white ring with an inner radius
of <tt class="mmMath">50</tt> and an outer radius of <tt
class="mmMath">60</tt>:

<pre class="mmMMExpression">
grayColor(inintv(r,50,60))
</pre>

<h3 class="mmSubSubSection">clamp</h3>

<p>Sometimes you have values which you want to lie within a given range.
In case they don't, you simply want them to take on the largest value
within the range, if they are too large, or the smallest if they are
too small.

<p>MathMap often does such operations authomatically, for example if you
produce colors with components larger than <tt>1</tt> or smaller than
<tt>0</tt>.

<p>If you have to it yourself, <tt>clamp</tt> can help you.  For
example, <tt>clamp(v,[0,0,0],[1,1,1])</tt> restricts every element of
<tt>v</tt> to be in the range from <tt>0</tt> to <tt>1</tt>.

<h3 class="mmSubSubSection">rand</h3>

<p>The function <tt>rand</tt> generates a random number.  It takes two
arguments: The minimum and the maximum value of the number to be
generated.  This expression, for examples, randomly scatters the
pixels of the input image (but not more than 10 pixels away from their
original location in both directions):

<pre class="mmMMExpression">
origValXY(x+rand(-10,10),y+rand(-10,10))
</pre>

<h3 class="mmSubSubSection">noise</h3>

<p>In image manipulation, one often needs a functions which is random but
doesn't change as abruptly as <tt>rand</tt> does.  <tt>noise</tt> is a
so-called <em>solid noise</em> function.  It takes a tuple of three
numbers and returns a value between <tt>-1</tt> and <tt>1</tt>.  If
the input arguments change only by a little, so does the resulting
value.  The overall "look" of the function is random, though.  It's
hard to describe, so it's best you see for yourself:

<pre>
grayColor(scale(noise([x/20,y/20,t*2]),-1,1,0,1))
</pre>

<p>As you can see, the third input value depends on <tt>t</tt>, so try
out changing <tt>t</tt>.  For <tt>t</tt> being <tt>0</tt>, the
resulting image looks like this:

<p class="mmFigure"><img src="noise.jpg">

<h2 class="mmSubSection"><a name="furtherInformation"></a>Further Information</h2>

<p class="mmText">This tutorial has, despite its length, not covered
all features and details of MathMap.  For example, we didn't even
mention loops (a programming language feature having nothing to do
with animations).

<p class="mmText">To get more detailed information about the MathMap
language, see the <a href="reference.html">MathMap Reference
Manual</a>.

<p class="mmText">A very good way to learn how to do things with
MathMap is to look at the examples supplied with it.  Pick the
examples you find interesting, look at their expressions, and try to
figure out how they work.

<p class="mmText">You might also want to look at the <a
href="http://www.complang.tuwien.ac.at/schani/">MathMap Homepage</a>
for announcements, new documentation or interesting links.

<p class="mmText">If you like MathMap, or if you have suggestions or
questions regarding the MathMap language or user interface, feel free
to <a href="mailto:schani@complang.tuwien.ac.at">contact the
authors</a>.  We are looking forward to your feedback.

</BODY>
</HTML>
