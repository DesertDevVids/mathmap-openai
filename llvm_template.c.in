/*
 * llvm_template.c.in
 *
 * MathMap
 *
 * Copyright (C) 2002-2009 Mark Probst
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#include <stdlib.h>
#include <math.h>
#include <complex.h>
#include <stdio.h>

/*
#if !$g
#define OPENSTEP
#endif
*/

#define IN_COMPILED_CODE

#include "opmacros.h"
#include "lispreader/pools.h"

#ifndef MIN
#define MIN(a,b)         (((a)<(b))?(a):(b))
#endif
#ifndef MAX
#define MAX(a,b)         (((a)<(b))?(b):(a))
#endif

#define M_PI		3.14159265358979323846	/* pi */

$def_edge_behaviour

$def_userval_image

$def_num_floatmap_channels

$def_userval_points

$def_max_debug_tuples

$def_tuple

typedef unsigned int color_t;

#define MAKE_RGBA_COLOR(r,g,b,a)            ((((color_t)(r))<<24)|(((color_t)(g))<<16)|(((color_t)(b))<<8)|((color_t)(a)))
#define RED(c)                              ((c)>>24)
#define GREEN(c)                            (((c)>>16)&0xff)
#define BLUE(c)                             (((c)>>8)&0xff)
#define ALPHA(c)                            ((c)&0xff)

$def_image_types

struct _mathmap_invocation_t;
struct _mathmap_frame_t;
struct _mathmap_slice_t;
struct _userval_t;
struct _image_t;

$def_filter_funcs

typedef struct
{
    double r, g, b, a;
} GimpRGB;

typedef struct _GtkWidget GtkWidget;

$def_userval

struct _input_drawable_t;
struct _mathfuncs_t;

$def_image

typedef struct _filter_t filter_t;
typedef struct _interpreter_insn_t interpreter_insn_t;
typedef struct _GArray GArray;
typedef void* initfunc_t;

$def_mathmap

$def_mathfuncs

$def_invocation_frame_slice

$def_builtins

$def_make_resize_image

$def_noise

struct _gsl_vector;
typedef struct _gsl_vector gsl_vector;
struct _gsl_matrix;
typedef struct _gsl_matrix gsl_matrix;

gsl_matrix * gsl_matrix_alloc (const size_t n1, const size_t n2);
void gsl_matrix_free (gsl_matrix * m);
void gsl_matrix_set(gsl_matrix * m, const size_t i, const size_t j, const double x);

gsl_vector *gsl_vector_alloc (const size_t n);
void gsl_vector_free (gsl_vector * v);
double gsl_vector_get (const gsl_vector * v, const size_t i);
void gsl_vector_set (gsl_vector * v, const size_t i, double x);

int gsl_linalg_HH_solve (gsl_matrix * A, const gsl_vector * b, gsl_vector * x);

#define GSL_PREC_SINGLE		1

double gsl_sf_ellint_Kcomp (double k, unsigned int mode);
double gsl_sf_ellint_Ecomp (double k, unsigned int mode);

double gsl_sf_ellint_F (double phi, double k, unsigned int mode);
double gsl_sf_ellint_E (double phi, double k, unsigned int mode);
double gsl_sf_ellint_P (double phi, double k, double n, unsigned int mode);
double gsl_sf_ellint_D (double phi, double k, double n, unsigned int mode);

double gsl_sf_ellint_RC (double x, double y, unsigned int mode);
double gsl_sf_ellint_RD (double x, double y, double z, unsigned int mode);
double gsl_sf_ellint_RF (double x, double y, double z, unsigned int mode);
double gsl_sf_ellint_RJ (double x, double y, double z, double p, unsigned int mode);

int gsl_sf_elljac_e (double u, double m, double *sn, double *cn, double *dn);

complex float cgamma (complex float z);

double gsl_sf_beta (double a, double b);

extern void save_debug_tuples (mathmap_invocation_t *invocation, int row, int col);

#undef OUTPUT_TUPLE
#define OUTPUT_TUPLE(t)			((*return_tuple = (t)), 0)

complex float
make_complex (float r, float i)
{
    return COMPLEX(r, i);
}

color_t
make_color (int r, int g, int b, int a)
{
    return MAKE_RGBA_COLOR(r, g, b, a);
}

mm_v2_t
make_v2 (float x, float y)
{
    return MAKE_V2(x, y);
}

mm_v3_t
make_v3 (float x, float y, float z)
{
    return MAKE_V3(x, y, z);
}

mm_m2x2_t
make_m2x2 (float a00, float a01,
	   float a10, float a11)
{
    return MAKE_M2X2(a00, a01, a10, a11);
}

float*
alloc_tuple (pools_t *pools, int n)
{
    return ALLOC_TUPLE(n);
}

void
tuple_set (float *tuple, int n, float x)
{
    TUPLE_SET(tuple, n, x);
}

int
get_invocation_img_width (mathmap_invocation_t *invocation)
{
    return invocation->img_width;
}

int
get_invocation_img_height (mathmap_invocation_t *invocation)
{
    return invocation->img_height;
}

int
get_invocation_render_width (mathmap_invocation_t *invocation)
{
    return invocation->render_width;
}

int
get_invocation_render_height (mathmap_invocation_t *invocation)
{
    return invocation->render_height;
}

float
get_invocation_image_R (mathmap_invocation_t *invocation)
{
    return invocation->image_R;
}

float
promote_int_to_float (int x)
{
    return (float)x;
}

complex float
promote_int_to_complex (int x)
{
    return (complex float)x;
}

complex float
promote_float_to_complex (float x)
{
    return x;
}

#undef OUTPUT_TUPLE
#define OUTPUT_TUPLE(x) 0

#define get_orig_val_pixel_func get_orig_val_pixel

#include "llvm-ops.h"
