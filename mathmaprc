((group "Distorts"
	(expression "Wave" "origVal(xy+xy:[sin(y*10+t*360),sin(x*10+t*360)]*3)")
	(expression "Square" "origVal(sign(xy)*xy^2/XY)")
	(expression "Slice" "q=t*360;\norigVal(xy+xy:[5*sign(cos(9*y+q)),5*sign(cos(9*x+q))])")
	(expression "Mercator" "origVal(xy*xy:[cos(90/Y*y+t*360),1])")
	(expression "Pond" "origVal(ra+ra:[sin(r*20+t*360)*3,0])")
	(expression "Enhanced Pond" "origVal(ra+ra:[sin(500000/(r+100)+t*360)*7,0])")
	(expression "Sea 1" "origVal(xy+xy:[10*(X/H)*sin(t*360+2000*Y*(-y+Y+60)^-1),0])")
	(expression "Sea 2" "origVal(xy+xy:[0,5*sin(t*360+2000*Y*(-y+Y+60)^-1)])")
	(expression "Sea 3" "s=sin(t*360+2000*Y*(-y+Y+60)^-1);\norigVal(xy+xy:[10*s,5*s])")
	(expression "Twirl 90" "origVal(ra+ra:[0,(r/R-1)*(t-0.5)*360])")
	(expression "Sphere" "p=r/(X*2);\norigValRA(r*(1-inintv(p,-0.5,0.5))+X/90*asin(inintv(p,-0.5,0.5)*r/X),a)")
	(expression "Jitter" "origValRA(r,a+(a+t*8)%8-4)")
	(expression "Circular Slice" "origValRA(r,a+(r+t*6)%6-3)")
	(expression "Fisheye" "origValRA(r^(2-t)/R^(1-t),a)")
	(expression "Center Shake" "origValXY(x+max(0,cos(x*2))*5*max(0,cos(y*2))*cos(y*10),y+max(0,cos(x*2))*5*max(0,cos(y*2))*cos(x*10))")
	(expression "Inverse Lambert Azimuthal Projection" "# Thanks to Carlos A. Furuti\nc=2*asin(r/Y);\nphi =\n    if r == 0 then\n        0\n    else\n        asin(y*sin(c)/r)\n    end;\norigVal(xy:[atan(x*sin(c),r*cos(c))*X/180,phi*Y/90])")
	(expression "Curve Bend" "alpha = user_slider(\"alpha\",0,360);\ndir = xy:[cos(alpha),sin(alpha)];\nndir = xy:[-dir[1],dir[0]];\np = xy / m2x2:[dir[0],-ndir[0],\n               dir[1],-ndir[1]];\npt = dir * p[0];\nvec = xy - pt;\ndist = -p[1] / R;\npos = 0.5 + p[0] / R / 2;\nlower = 1 / (user_curve(\"lower\",pos) * 4 - 2);\nupper = 1 / (user_curve(\"upper\",pos) * 4 - 2);\nf = lower + ((dist + 1) / 2) * (upper - lower);\norigVal(pt + ndir * f * R)")
	(expression "Peel Animation" "# tomr@aceldama.com\nif (r > X) then\n    user_color(\"Outside\");\nelse\n    rad = (X*t);\n    if (r > rad) then\n        origVal(ra:[rad*(1-(r-rad)/(X-rad)), a]);\n    else\n        origVal(xy);\n    end\nend")
	(expression "Radial Eversion" "# tomr@aceldama.com\nif (r > X) then\n    user_color(\"Outside\");\nelse\n    origVal(ra:[X-r, a]);\nend"))
 (group "Blur"
	(expression "Mosaic" "origVal(xy-xy%5)")
	(expression "Radial Mosaic" "origVal(ra-ra%5+ra:[0,2.5])")
	(expression "Radial Mosaic Bertl Edition" "# Thanks to Herbert Poetzl\nA=300*t;\nB=(A*2.2)^0.5;\npi360=pi/360;\nn=floor(r/B)+0.5;\nalpha=360/floor(360/(A/(pi360*(n-0.5)*B*B)));\norigVal(ra:[(n*A/(alpha*pi360))^0.5,a-a%alpha])")
	(expression "Zoom-Twist" "# tomr@aceldama.com\nsamples = user_slider(\"Samples\", 4, 64);\nzoom = user_slider(\"Zoom\", 0, 1);\ntfact = user_slider(\"Twist\", 0, 360) * (user_curve(\"Twist at t\", t) - 0.5);\nzfact = (user_curve(\"Zoom at t\", t)-0.5) * (user_curve(\"Zoom at r\", r/X)-0.5) * zoom;\nif zfact > 0 then\n    sample = 0;\n    total = rgba:[0,0,0,0];\n    while (sample < samples) do\n        radj = zfact * (user_curve(\"Sampling shape\", sample/samples)-0.5);\n        sr = r + radj * X;\n        sa = a + (user_curve(\"Twist at r\", radj)-0.5) * tfact;   \n        total = total + origVal(ra:[sr, sa]);\n        sample = sample+1;\n    end;\n    total/samples; \nelse\n    origVal(xy);\nend")
	(expression "Spin-Zoom" "# tomr@aceldama.com\nzoom = user_slider(\"Zoom\", 0, 1);\nangle = user_slider(\"Angle\", 0, 360);\nsamples = user_slider(\"Samples\", 2, 64);\nzfact = (user_curve(\"Zoom at r\", r/X)*zoom*X)/samples;\nrfact = (user_curve(\"Position at t\", t)*angle)/samples;\nif zfact > 0 then\n    sample = 0;\n    total = rgba:[0,0,0,0];\n    while (sample < samples) do\n        total = total + origVal(ra + ra:[zfact, rfact] * sample);\n        sample = sample+1;\n    end;\n    total/samples;\nelse\n    origVal(xy);\nend"))
 (group "Edge-Detect"
	(expression "Random Edge Detect" "origVal(xy)-origVal(xy-xy:[rand(1,4),rand(1,4)])"))
 (group "Render"
	(expression "Spiral" "q=sin((r-a*0.1)*10+t*360)*0.5+0.5;\norigVal(xy)*rgba:[q,q,q,1]")
	(expression "Alpha Spiral" "origVal(xy)*rgba:[1,1,1,0]+rgba:[0,0,0,sin((r-a*0.1)*10+t*360)*0.5+0.5]")
	(expression "Darts" "p=origVal(xy);\np=if inintv((a-9)%36,0,18)\n    then\n        p\n    else\n        -p+1\n    end;\nif inintv(r%80,68,80)\nthen\n    p\nelse\n    -p+1\nend")
	(expression "RGB Solid Noise" "g = user_slider(\"granularity\",0,50);\nnxy = xy/R*g;\nrz = user_slider(\"rz\",0,10);\ngz = user_slider(\"gz\",0,10);\nbz = user_slider(\"bz\",0,10);\nrgba:[noise3([nxy[0],nxy[1],rz]),noise3([nxy[0],nxy[1],gz]),noise3([nxy[0],nxy[1],bz]),1]*0.5+0.5")
	(expression "Sine Wave" "grayColor(sin(r*10+t*360)*0.5+0.5)")
	(expression "Grid" "grayColor(if (x%20)*(y%20) then 1 else 0 end)")
	(expression "Moire 1" "q=t*360;\nabs(rgba:[sin(15*r+q)+sin(15*a+q),sin(17*r+q)+sin(17*a+q),sin(19*r+q)+sin(19*a+q),2])*0.5")
	(expression "Moire 2" "grayColor(sin(x*y+t*360)*0.5+0.5)")
	(expression "Mandelbrot" "p=ri:(xy/xy:[X,X]*1.5-xy:[0.5,0]);\nc=ri:[0,0];\niter=0;\nwhile abs(c)<2 && iter<31\ndo\n    c=c*c+p;\n    iter=iter+1\nend;\ngradient(iter/32)"))
 (group "Colors"
	(expression "Desaturate" "p=origVal(xy);\ngrayaColor(gray(p),alpha(p))")
	(expression "Gamma Correction" "p=origVal(xy);rgbaColor(curve(red(p)),curve(green(p)),curve(blue(p)),alpha(p))")
	(expression "Gamma Correction 2" "p=origVal(xy);g=gray(p);rgbaColor(red(p)*curve(g)/g,green(p)*curve(g)/g,blue(p)*curve(g)/g,alpha(p))")
	(expression "Colorify" "gradient((gray(origVal(xy))+t)%1)"))
 (group "Noise"
	(expression "Scatter" "origVal(xy+xy:[rand(-30,30),rand(-30,30)]*t)")
	(expression "Life" "num=(gray(origVal(xy+xy:[-1,-1]))>0.5)+\n(gray(origVal(xy+xy:[-1,0]))>0.5)+\n(gray(origVal(xy+xy:[-1,1]))>0.5)+\n(gray(origVal(xy+xy:[0,-1]))>0.5)+\n(gray(origVal(xy+xy:[0,1]))>0.5)+\n(gray(origVal(xy+xy:[1,-1]))>0.5)+\n(gray(origVal(xy+xy:[1,0]))>0.5)+\n(gray(origVal(xy+xy:[1,1]))>0.5);\nval=gray(origVal(xy))>0.5;\nrgba:[0,0,0,1]+rgba:[1,1,1,0]*if num==2 then val else if num==3 then 1 else 0 end end"))
 (group "Map"
	(expression "Tile" "origVal((xy+XY)*2%WH-XY)")
	(expression "Make Seamless" "# Edge Behaviour must be Wrap\nax=abs(x)/X;ay=abs(y)/Y;\nx1=max(0,ax-ay);\ny1=max(0,ay-ax);\nx2=min(1,ax+(1-ay));\ny2=min(1,ay+(1-ax));\nweight=clamp(1-(ax-x1)/(x2-x1),0,1);\nlerp(weight,origVal(xy+XY),origVal(xy))")
	(expression "Displace" "origVal(xy+xy:[(gray(origVal(xy,user_image(\"x image\")))-0.5)*user_slider(\"x disp\",0,100)*2,\n               (gray(origVal(xy,user_image(\"y image\")))-0.5)*user_slider(\"y disp\",0,100)*2])")
	(expression "Sphere" "# Thanks to Herbert Poetzl\nrd=0.9*min(X,Y);\nif r>rd then\n    user_color(\"back\")\nelse\n    alpha=user_slider(\"alpha\",0,360);\n    beta=user_slider(\"beta\",0,360);\n    gamma=user_slider(\"gamma\",0,360);\n    sa=sin(alpha);\n    sb=sin(beta);\n    ca=cos(alpha);\n    cb=cos(beta);\n    theta=a;\n    phi=acos(r/rd);\n    x0=cos(theta)*cos(phi);\n    y0=sin(theta)*cos(phi);\n    z0=sin(phi);\n    x1=ca*x0+sa*y0;\n    z1=-sa*-sb*x0+ca*-sb*y0+cb*z0;\n    if z1 >= 0 || 1 then\n        y1=cb*-sa*x0+cb*ca*y0+sb*z0\n    else\n        z1=z1-2*cb*z0;\n        y1=cb*-sa*x0+cb*ca*y0-sb*z0\n    end;\n    theta1=atan(-x1/y1)+(if y1>0 then 90 else 270 end);\n    phi1=asin(z1);\n    origVal(xy:[((theta1*2+gamma)%360-180)/180*X,-phi1/90*Y])\nend")
	(expression "Sphere with Reflection" "# Thanks to Herbert Poetzl\nrd=0.9*min(X,Y);\nif r>rd then\n    user_color(\"back\")\nelse\n    alpha=user_slider(\"alpha\",0,360);\n    beta=user_slider(\"beta\",0,360);\n    gamma=user_slider(\"gamma\",0,360);\n    thetal=100; phil=45;\n    lv=normalize([user_slider(\"lx\",-1,1),user_slider(\"ly\",-1,1),user_slider(\"lz\",-1,1)]);\n    sa=sin(alpha);\n    sb=sin(beta);\n    ca=cos(alpha);\n    cb=cos(beta);\n    theta=a;\n    phi=acos(r/rd);\n    m0=cos(phi);\n    x0=cos(theta)*m0;\n    y0=sin(theta)*m0;\n    z0=sin(phi);\n    x1=ca*x0+sa*y0;\n    m1=ca*y0-sa*x0;\n    z1=cb*z0-sb*m1;\n    y1=cb*m1+sb*z0;\n    diffq=dotp(lv,[x1,y1,z1]);\n    theta1=atan(-x1/y1)+(if y1>0 then 90 else 270 end);\n    phi1=asin(z1);\n    p=origVal(xy:[((theta1+gamma)%360-180)/180*X,-phi1/90*Y]);\n    p*(1-diffq)+rgba:[1,1,1,1]*diffq\nend")
	(expression "Mugl" "# Thanks to Herbert Poetzl\nsl=30;\nnx=floor(x/sl-0.5); ny=floor(y/sl-0.5);\nalpha=[0,0,0,0];\nradii=[0,0,0,0];\nphii=[0,0,0,0];\nxc=[0,0,0,0];\nyc=[0,0,0,0];\nnummugls=5;\nmuglwinkl=360/nummugls/2;\nheuslfaktor=sl/2;\ni=0; while i < 4 do\n    ix=nx+i%2;\n    iy=ny+floor(i/2);\n    xc[i]=(ix+0.5)*sl;\n    yc[i]=(iy+0.5)*sl;\n    alpha[i]=ix*10+iy*5;\n    kurde=toRA(xy:[x-xc[i],y-yc[i]])+ra:[0,pmod(alpha[i],360)];\n    phii[i]=kurde[1];\n    radii[i]=heuslfaktor/cos(abs(kurde[1]%(muglwinkl*2)-muglwinkl));\n    i = i + 1\nend;\ni=0;found=0;\nwhile !found && i<4 do\n    heuslkurde=toRA(xy:[x-xc[i],y-yc[i]])+ra:[0,alpha[i]];\n    if heuslkurde[0]<radii[i] then\n        found = 1\n    else\n        i=i+1\n    end\nend;\nif i >= 4 then\n    rgba:[0,0,1,1]\nelse\n    if heuslkurde[0] < radii[i]-1.5 then\n        origVal(toXY(heuslkurde)+xy:[xc[i],yc[i]])\n    else\n        rgba:[0,0,0,1]\n    end\nend"))
 (group "Combine"
	(expression "Depth Merge" "overlap = user_slider(\"overlap\",0.001,2);\noffset = user_slider(\"offset\",-1,1);\nscale1 = user_slider(\"scale1\",-1,1);\nscale2 = user_slider(\"scale2\",-1,1);\ndepth1 = gray(origVal(xy,user_image(\"depth1\")));\ndepth2 = gray(origVal(xy,user_image(\"depth2\")));\nfrac = clamp(((depth2 * scale2 - (depth1 * scale1 + offset)) / overlap + 1) / 2, 0, 1);\nc1 = origVal(xy,user_image(\"image1\"));\nc2 = origVal(xy,user_image(\"image2\"));\nclamp(lerp(frac,c2,c1),rgba:[0,0,0,0],rgba:[1,1,1,1])")))
