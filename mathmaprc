{
  Distorts = {
    wave = "origVal(xy+xy:[sin(y*10+t*360),sin(x*10+t*360)]*3)";
    square = "origVal(sign(xy)*xy^2/XY)";
    slice = "q=t*360;\norigVal(xy+xy:[5*sign(cos(9*y+q)),5*sign(cos(9*x+q))])";
    mercator = "origVal(xy*xy:[cos(90/Y*y+t*360),1])";
    pond = "origVal(ra+ra:[sin(r*20+t*360)*3,0])";
    "enhanced pond" = "origVal(ra+ra:[sin(500000/(r+100)+t*360)*7,0])";
    "sea 1" = "origVal(xy+xy:[10*(X/H)*sin(t*360+2000*Y*(y+Y+60)^-1),0])";
    "sea 2" = "origVal(xy+xy:[0,5*sin(t*360+2000*Y*(y+Y+60)^-1)])";
    "sea 3" = "s=sin(t*360+2000*Y*(y+Y+60)^-1);\norigVal(xy+xy:[10*s,5*s])";
    "twirl 90" = "origVal(ra+ra:[0,(r/R-1)*(t-0.5)*360])";
    sphere = "p=r/(X*2);\norigValRA(r*(1-inintv(p,-0.5,0.5))+X/90*asin(inintv(p,-0.5,0.5)*r/X),a)";
    jitter = "origValRA(r,a+(a+t*8)%8-4)";
    "circular slice" = "origValRA(r,a+(r+t*6)%6-3)";
    fisheye = "origValRA(r^(2-t)/R^(1-t),a)";
    "center shake" = "origValXY(x+max(0,cos(x*2))*5*max(0,cos(y*2))*cos(y*10),y+max(0,cos(x*2))*5*max(0,cos(y*2))*cos(x*10))";
  };
  Blur = {
    mosaic = "origVal(xy-xy%5)";
    "radial mosaic" = "origVal(ra-ra%5+ra:[0,2.5])";
    "radial mosaic bertl edition" = "# Thanks to Herbert Poetzl\nA=300*t;\nB=(A*2.2)^0.5;\npi360=pi/360;\nn=floor(r/B)+0.5;\nalpha=360/floor(360/(A/(pi360*(n-0.5)*B*B)));\norigVal(ra:[(n*A/(alpha*pi360))^0.5,a-a%alpha])";
  };
  "Edge-Detect" = {
    "random edge detect" = "origVal(xy)-origVal(xy-xy:[rand(1,4),rand(1,4)])";
  };
  Render = {
    spiral = "q=sin((r-a*0.1)*10+t*360)*0.5+0.5;\norigVal(xy)*rgba:[q,q,q,1]";
    "alpha spiral" = "origVal(xy)*rgba:[1,1,1,0]+rgba:[0,0,0,sin((r-a*0.1)*10+t*360)*0.5+0.5]";
    darts = "p=origVal(xy);\np=if inintv((a-9)%36,0,18)\n    then\n        p\n    else\n        -p+1\n    end;\nif inintv(r%80,68,80)\nthen\n    p\nelse\n    -p+1\nend";
    "sine wave" = "grayColor(sin(r*10+t*360)*0.5+0.5)";
    grid = "grayColor(if (x%20)*(y%20) then 1 else 0 end)";
    moire1 = "q=t*360;\nabs(rgba:[sin(15*r+q)+sin(15*a+q),sin(17*r+q)+sin(17*a+q),sin(19*r+q)+sin(19*a+q),2])*0.5";
    moire2 = "grayColor(sin(x*y+t*360)*0.5+0.5)";
    mandelbrot = "p=ri:(xy/xy:[X,X]*1.5-xy:[0.5,0]);\nc=ri:[0,0];\niter=0;\nwhile abs(c)<2 && iter<31\ndo\n    c=c*c+p;\n    iter=iter+1\nend;\ngradient(iter/32)";
  };
  Colors = {
    desaturate = "p=origVal(xy);\ngrayaColor(gray(p),alpha(p))";
    "gamma correction" = "p=origVal(xy);rgbaColor(curve(red(p)),curve(green(p)),curve(blue(p)),alpha(p))";
    "gamma correction 2" = "p=origVal(xy);g=gray(p);rgbaColor(red(p)*curve(g)/g,green(p)*curve(g)/g,blue(p)*curve(g)/g,alpha(p))";
    colorify = "gradient((gray(origVal(xy))+t)%1)";
  };
  Noise = {
    scatter = "origVal(xy+xy:[rand(-30,30),rand(-30,30)]*t)";
    life = "num=(gray(origVal(xy+xy:[-1,-1]))>0.5)+\n(gray(origVal(xy+xy:[-1,0]))>0.5)+\n(gray(origVal(xy+xy:[-1,1]))>0.5)+\n(gray(origVal(xy+xy:[0,-1]))>0.5)+\n(gray(origVal(xy+xy:[0,1]))>0.5)+\n(gray(origVal(xy+xy:[1,-1]))>0.5)+\n(gray(origVal(xy+xy:[1,0]))>0.5)+\n(gray(origVal(xy+xy:[1,1]))>0.5);\nval=gray(origVal(xy))>0.5;\nrgba:[0,0,0,1]+rgba:[1,1,1,0]*if num==2 then val else if num==3 then 1 else 0 end end";
  };
  Map = {
    tile = "origVal((xy+XY)*2%WH-XY)";
    sphere = "# Thanks to Herbert Poetzl\nrd=0.9*min(X,Y);\nif r>rd then\n    rgba:[0,0,0,0]\nelse\n    alpha=300; beta=120; gamma=t*360;\n    sa=sin(alpha);\n    sb=sin(beta);\n    ca=cos(alpha);\n    cb=cos(beta);\n    theta=a;\n    phi=acos(r/rd);\n    x0=cos(theta)*cos(phi);\n    y0=sin(theta)*cos(phi);\n    z0=sin(phi);\n    x1=ca*x0+sa*y0;\n    z1=-sa*-sb*x0+ca*-sb*y0+cb*z0;\n    if z1 >= 0 || 1 then\n        y1=cb*-sa*x0+cb*ca*y0+sb*z0\n    else\n        z1=z1-2*cb*z0;\n        y1=cb*-sa*x0+cb*ca*y0-sb*z0\n    end;\n    theta1=atan(-x1/y1)+(if y1>0 then 90 else 270 end);\n    phi1=asin(z1);\n    origVal(xy:[((theta1*2+gamma)%360-180)/180*X,-phi1/90*Y])\nend";
    "sphere with reflection" = "# Thanks to Herbert Poetzl\nrd=0.9*min(X,Y);\nif r>rd then\n    rgba:[0,0,0,0]\nelse\n    alpha=300; beta=80; gamma=t*360;\n    thetal=100; phil=45;\n    lv=normalize([1,1,2]);\n    sa=sin(alpha);\n    sb=sin(beta);\n    ca=cos(alpha);\n    cb=cos(beta);\n    theta=a;\n    phi=acos(r/rd);\n    m0=cos(phi);\n    x0=cos(theta)*m0;\n    y0=sin(theta)*m0;\n    z0=sin(phi);\n    x1=ca*x0+sa*y0;\n    m1=ca*y0-sa*x0;\n    z1=cb*z0-sb*m1;\n    y1=cb*m1+sb*z0;\n    diffq=dotp(lv,[x1,y1,z1]);\n    theta1=atan(-x1/y1)+(if y1>0 then 90 else 270 end);\n    phi1=asin(z1);\n    p=origVal(xy:[((theta1+gamma)%360-180)/180*X,-phi1/90*Y]);\n    p*(1-diffq)+rgba:[1,1,1,1]*diffq\nend";
    mugl = "# Thanks to Herbert Poetzl\nsl=30;\nnx=floor(x/sl-0.5); ny=floor(y/sl-0.5);\nalpha=[0,0,0,0];\nradii=[0,0,0,0];\nphii=[0,0,0,0];\nxc=[0,0,0,0];\nyc=[0,0,0,0];\nnummugls=5;\nmuglwinkl=360/nummugls/2;\nheuslfaktor=sl/2;\ni=0; while i < 4 do\n    ix=nx+i%2;\n    iy=ny+floor(i/2);\n    xc[i]=(ix+0.5)*sl;\n    yc[i]=(iy+0.5)*sl;\n    alpha[i]=ix*10+iy*5;\n    kurde=toRA(xy:[x-xc[i],y-yc[i]])+ra:[0,pmod(alpha[i],360)];\n    phii[i]=kurde[1];\n    radii[i]=heuslfaktor/cos(abs(kurde[1]%(muglwinkl*2)-muglwinkl));\n    i = i + 1\nend;\ni=0;found=0;\nwhile !found && i<4 do\n    heuslkurde=toRA(xy:[x-xc[i],y-yc[i]])+ra:[0,alpha[i]];\n    if heuslkurde[0]<radii[i] then\n        found = 1\n    else\n        i=i+1\n    end\nend;\nif i >= 4 then\n    rgba:[0,0,1,1]\nelse\n    if heuslkurde[0] < radii[i]-1.5 then\n        origVal(toXY(heuslkurde)+xy:[xc[i],yc[i]])\n    else\n        rgba:[0,0,0,1]\n    end\nend";
  };
}
